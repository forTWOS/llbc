// The MIT License (MIT)

// Copyright (c) 2013 lailongwei<lailongwei@126.com>
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of 
// this software and associated documentation files (the "Software"), to deal in 
// the Software without restriction, including without limitation the rights to 
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of 
// the Software, and to permit persons to whom the Software is furnished to do so, 
// subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all 
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS 
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR 
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

//!!! This file is auto generated by script tool, do not modify it!!!

#ifndef __PYLLBC_AUTOGEN_SRC_PYLLBC_SCRIPTS_H__
#define __PYLLBC_AUTOGEN_SRC_PYLLBC_SCRIPTS_H__

#include "pyllbc/common/LibHeader.h"
#include "pyllbc/common/ScriptIntegrator.h"

class pyllbc_Scripts
{
public:
    pyllbc_Scripts()
    {
        _scripts.insert(::std::make_pair("Packet.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcPacket(object):\n"
"    def __init__(self, svc, sender_svc_id, session_id, local_ip, local_port, peer_ip, peer_port, opcode, status, status_desc, data, packet_cobj):\n"
"        self.svc = svc\n"
"        self.sender_svc_id = sender_svc_id\n"
"        self.session_id = session_id\n"
"        self.local_ip = local_ip\n"
"        self.local_port = local_port\n"
"        self.peer_ip = peer_ip\n"
"        self.peer_port = peer_port\n"
"        self.opcode = opcode\n"
"        self.status = status\n"
"        self.status_desc = status_desc\n"
"        self.data = data\n"
"        self._packet_cobj = packet_cobj\n"
"\n"
"        self._str = 'sender_svc_id: {}, recver_svc_id: {}, session_id: {}, local: {}:{}, peer: {}:{}, opcode: {}, status: {}, status_desc: {}, data: {}'.format(\n"
"                sender_svc_id, self.recver_svc_id, session_id, local_ip, local_port, peer_ip, peer_port, opcode, status, status_desc, data)\n"
"\n"
"    @property\n"
"    def recver_svc_id(self):\n"
"        return self.svc.id\n"
"\n"
"    def __str__(self):\n"
"        return self._str\n"
"\n"
"llbc.Packet = pyllbcPacket\n"
"\n"
)));
        _scripts.insert(::std::make_pair("RegHolder.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"from weakref import ref\n"
"from types import TypeType, ClassType\n"
"import functools\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcSvcRegInfo(object):\n"
"    \"\"\"\n"
"    Service auto register information holder.\n"
"    \"\"\"\n"
"    # info type enumeration\n"
"    BeginType = 0\n"
"    Coder = BeginType + 0 # coder type\n"
"    Handler = BeginType + 1 # handler type\n"
"    PreHandler = BeginType + 2 # prehandler type\n"
"    UnifyPreHandler = BeginType + 3 # unify prehandler type\n"
"\n"
"    ExcHandler = BeginType + 4 # packet-handler's exception handler\n"
"    ExcPreHandler = BeginType + 5 # packet-prehandler's exception handler\n"
"    DftExcHandler = BeginType + 6 # default packet-handler's exception handler\n"
"    DftExcPreHandler = BeginType + 7 # default packet-prehandler's exception handler\n"
"\n"
"    FrameExcHandler = BeginType + 8 # frame exception handler\n"
"\n"
"    UnSpecific = BeginType + 9 # unspecific\n"
"\n"
"    def __init__(self, wrapped):\n"
"        self._wrapped = ref(wrapped)\n"
"\n"
"        self._type = self.UnSpecific\n"
"        self._fmt = ''\n"
"        self._enopcode = None\n"
"        self._deopcodes = []\n"
"\n"
"        self._hldropcodes = []\n"
"        self._prehldropcodes = []\n"
"        self._exc_hldropcodes = []\n"
"        self._exc_prehldropcodes = []\n"
"\n"
"        self._svcs = set()\n"
"\n"
"        self._asfacade = False\n"
"\n"
"    @property\n"
"    def wrapped(self):\n"
"        return self._wrapped()\n"
"\n"
"    @property\n"
"    def regtype(self):\n"
"        return self._type\n"
"    @regtype.setter\n"
"    def regtype(self, value):\n"
"        self._type = value\n"
"\n"
"    @property\n"
"    def fmt(self):\n"
"        return self._fmt\n"
"    @fmt.setter\n"
"    def fmt(self, value):\n"
"        self._fmt = value\n"
"\n"
"    @property\n"
"    def enopcode(self):\n"
"        return self._enopcode\n"
"    @enopcode.setter\n"
"    def enopcode(self, value):\n"
"        self._enopcode = value\n"
"\n"
"    @property\n"
"    def deopcodes(self):\n"
"        return self._deopcodes\n"
"\n"
"    @property\n"
"    def hldropcodes(self):\n"
"        return self._hldropcodes\n"
"\n"
"    @property\n"
"    def prehldropcodes(self):\n"
"        return self._prehldropcodes\n"
"\n"
"    @property\n"
"    def exc_hldropcodes(self):\n"
"        return self._exc_hldropcodes\n"
"\n"
"    @property\n"
"    def exc_prehldropcodes(self):\n"
"        return self._exc_prehldropcodes\n"
"\n"
"    @property\n"
"    def svcs(self):\n"
"        return self._svcs\n"
"\n"
"    @property\n"
"    def asfacade(self):\n"
"        return self._asfacade\n"
"    @asfacade.setter\n"
"    def asfacade(self, value):\n"
"        self._asfacade = value\n"
"\n"
"    def add_deocodes(self, *opcodes):\n"
"        for op in opcodes:\n"
"            if op not in self._deopcodes:\n"
"                self._deopcodes.append(op)\n"
"        return self\n"
"\n"
"    def add_hldropcodes(self, *opcodes):\n"
"        for op in opcodes:\n"
"            if op not in self._hldropcodes:\n"
"                self._hldropcodes.append(op)\n"
"        return self\n"
"\n"
"    def add_prehldropcodes(self, *opcodes):\n"
"        for op in opcodes:\n"
"            if op not in self._prehldropcodes:\n"
"                self._prehldropcodes.append(op)\n"
"        return self\n"
"\n"
"    def add_exc_hldropcodes(self, *opcodes):\n"
"        for op in opcodes:\n"
"            if op not in self._exc_hldropcodes:\n"
"                self._exc_hldropcodes.append(op)\n"
"        return self\n"
"\n"
"    def add_exc_prehldropcodes(self, *opcodes):\n"
"        for op in opcodes:\n"
"            if op not in self._exc_prehldropcodes:\n"
"                self._exc_prehldropcodes.append(op)\n"
"        return self\n"
"\n"
"    def add_svcs(self, *svcs):\n"
"        self._svcs.update(svcs)\n"
"        return self\n"
"\n"
"    def decorate(self, to_svc):\n"
"        wrapped = self._wrapped()\n"
"        if wrapped is None:\n"
"            return\n"
"        elif self._svcs and to_svc.name not in self._svcs:\n"
"            return\n"
"\n"
"        ty = self._type\n"
"        if ty == self.Coder and \\\n"
"                to_svc.type != llbc.Service.RAW:\n"
"            if self._enopcode is not None:\n"
"                # print 'register encoder {}:{}'.format(self._enopcode, wrapped)\n"
"                to_svc.registerencoder(self._enopcode, wrapped)\n"
"            if self._deopcodes:\n"
"                # print 'register decoder {}:{}'.format(self._deopcodes, wrapped)\n"
"                map(lambda op: to_svc.registerdecoder(op, wrapped), self._deopcodes)\n"
"\n"
"        elif ty == self.Handler:\n"
"            map(lambda op: to_svc.subscribe(op, wrapped()), self._hldropcodes)\n"
"        elif ty == self.PreHandler:\n"
"            map(lambda op: to_svc.presubscribe(op, wrapped()), self._prehldropcodes)\n"
"        elif ty == self.UnifyPreHandler:\n"
"            to_svc.unify_presubscribe(wrapped())\n"
"\n"
"        elif ty == self.ExcHandler:\n"
"            map(lambda op: to_svc.set_subscribe_exc_handler(op, wrapped()), self._exc_hldropcodes)\n"
"        elif ty == self.ExcPreHandler:\n"
"            map(lambda op: to_svc.set_presubscribe_exc_handler(op, wrapped()), self._exc_prehldropcodes)\n"
"        elif ty == self.DftExcHandler:\n"
"            to_svc.set_default_subscribe_exc_handler(wrapped())\n"
"        elif ty == self.DftExcPreHandler:\n"
"            to_svc.set_default_presubscribe_exc_handler(wrapped())\n"
"\n"
"        if self._asfacade:\n"
"            to_svc.registerfacade(wrapped())\n"
"\n"
"    def decorate_cls(self, to_svc_cls):\n"
"        wrapped = self._wrapped()\n"
"        if wrapped is None:\n"
"            return\n"
"\n"
"        ty = self._type\n"
"        if ty == self.FrameExcHandler:\n"
"            to_svc_cls.set_frame_exc_handler(wrapped())\n"
"\n"
"    def __str__(self):\n"
"        return 'wrapped:{}, regtype:{}, fmt:{}, enopcode:{}, deopcodes:{}, hldropcodes:{}, prehldropcodes:{}, \\\n"
"                exc_hldropcodes: {}, exc_prehldropcodes: {}, svcs:{}, asfacade:{}'.format(\n"
"                self.wrapped, self._type, self._fmt, self._enopcode, self._deopcodes, self._hldropcodes, self._prehldropcodes, \n"
"                self._exc_hldropcodes, self._exc_prehldropcodes, self._svcs, self._asfacade)\n"
"\n"
"llbc.inl.SvcRegInfo = pyllbcSvcRegInfo\n"
"\n"
"class pyllbcSvcRegsHolder(object):\n"
"    \"\"\"\n"
"    Service register info holder.\n"
"    \"\"\"\n"
"    _bound_regs = {} # key: service name, value: register set.\n"
"    _unbound_regs = set()\n"
"\n"
"    _cls_decorated = False\n"
"\n"
"    @classmethod\n"
"    def update(cls, reg):\n"
"        if not reg.svcs:\n"
"            cls._unbound_regs.update((reg, ))\n"
"        else:\n"
"            if reg in cls._unbound_regs:\n"
"                cls._unbound_regs.remove(reg)\n"
"            for svc in reg.svcs:\n"
"                if svc not in cls._bound_regs:\n"
"                    cls._bound_regs.update({svc: set()})\n"
"                cls._bound_regs[svc].update((reg, ))\n"
"\n"
"    @classmethod\n"
"    def decorate(cls, to_svc):\n"
"        bound_regs = cls._bound_regs.get(to_svc.name)\n"
"        if bound_regs:\n"
"            map(lambda reg: reg.decorate(to_svc), bound_regs)\n"
"        map(lambda reg: reg.decorate(to_svc), cls._unbound_regs)\n"
"\n"
"    @classmethod\n"
"    def decorate_cls(cls):\n"
"        if cls._cls_decorated:\n"
"            return\n"
"\n"
"        will_decorate = llbc.Service\n"
"        for bound_regs in cls._bound_regs.itervalues():\n"
"            map(lambda reg: reg.decorate_cls(will_decorate), bound_regs)\n"
"        map(lambda reg: reg.decorate_cls(will_decorate), cls._unbound_regs)\n"
"\n"
"        cls._cls_decorated = True\n"
"\n"
"llbc.inl.SvcRegsHolder = pyllbcSvcRegsHolder\n"
"\n"
"def pyllbc_extractreg(wrapped, ty):\n"
"    \"\"\"\n"
"    Extract wrapped class/function library register info data, if not exist, will create it.\n"
"    \"\"\"\n"
"    if not isinstance(wrapped, (TypeType, ClassType)):\n"
"        raise llbc.error('@forsend/@forrecv/@handler/@prehandler/@unify_prehandler/@exc_handler/@exc_prehandler/@bindto decorator ' \\\n"
"                'must decorate class type object, could not decorate {}'.format(type(wrapped)))\n"
"\n"
"    RegCls = llbc.inl.SvcRegInfo\n"
"\n"
"    libkey = '__pyllbcreg__'\n"
"    if not hasattr(wrapped, libkey):\n"
"        setattr(wrapped, libkey, RegCls(wrapped))\n"
"\n"
"    reg = getattr(wrapped, libkey)\n"
"    if reg.regtype == RegCls.UnSpecific:\n"
"        reg.regtype = ty\n"
"    elif ty != RegCls.UnSpecific and ty != reg.regtype:\n"
"        raise llbc.error('conflict to use @handler/@prehandler/@unify_prehandler/@exc_handler/@exc_prehandler \\\n"
"                and @forsend/@forrecv decorator in the same class: {}'.format(wrapped))\n"
"\n"
"    return reg\n"
"\n"
"def pyllbc_frame_exc_handler(handler):\n"
"    \"\"\"\n"
"    Decorate service per-frame exception handler.\n"
"    Handler must has __call__() method.\n"
"    \"\"\"\n"
"    RegCls = llbc.inl.SvcRegInfo\n"
"    RegsHolder = llbc.inl.SvcRegsHolder\n"
"\n"
"    reg = pyllbc_extractreg(handler, RegCls.FrameExcHandler)\n"
"    RegsHolder.update(reg)\n"
"    return handler\n"
"\n"
"llbc.frame_exc_handler = pyllbc_frame_exc_handler\n"
"\n"
"def __pyllbc_normalize_opcodes(opcodes):\n"
"    libkey = '__pyllbcreg__'\n"
"    RegCls = llbc.inl.SvcRegInfo\n"
"    \n"
"    normalized = []\n"
"    for opcode in opcodes:\n"
"        if hasattr(opcode, 'OP'):\n"
"            normalized.append(opcode.OP)\n"
"        elif hasattr(opcode, 'OPCODE'):\n"
"            normalized.append(opcode.OPCODE)\n"
"        elif hasattr(opcode, libkey):\n"
"            opcode_reg = getattr(opcode, libkey)\n"
"            if opcode_reg.regtype == RegCls.Coder:\n"
"                for opcode_deopcode in opcode_reg.deopcodes:\n"
"                    if opcode_deopcode not in normalized:\n"
"                        normalized.append(opcode_deopcode)\n"
"        else:\n"
"            normalized.append(opcode)\n"
"\n"
"    return normalized \n"
"\n"
"def pyllbc_handler(*opcodes):\n"
"    \"\"\"\n"
"    Decorate packet-handler class, once decorate, library will use the class to handle packet.\n"
"    Handler must has __call__() method.\n"
"    \"\"\"\n"
"    def generator(handler):\n"
"        RegCls = llbc.inl.SvcRegInfo\n"
"        RegsHolder = llbc.inl.SvcRegsHolder\n"
"\n"
"        reg = pyllbc_extractreg(handler, RegCls.Handler)\n"
"\n"
"        converted = __pyllbc_normalize_opcodes(opcodes)\n"
"        RegsHolder.update(reg.add_hldropcodes(*converted))\n"
"        return handler \n"
"\n"
"    return generator\n"
"\n"
"llbc.handler = pyllbc_handler\n"
"\n"
"def pyllbc_prehandler(*opcodes):\n"
"    \"\"\"\n"
"    Decorate packet pre-handler class, once decorate, library will use the class to pre-handle packet.\n"
"    Handler must has __call__() method.\n"
"    \"\"\"\n"
"    def generator(handler):\n"
"        RegCls = llbc.inl.SvcRegInfo\n"
"        RegsHolder = llbc.inl.SvcRegsHolder\n"
"\n"
"        reg = pyllbc_extractreg(handler, RegCls.PreHandler)\n"
"\n"
"        converted = __pyllbc_normalize_opcodes(opcodes)\n"
"        RegsHolder.update(reg.add_prehldropcodes(*converted))\n"
"        return handler\n"
"\n"
"    return generator\n"
"\n"
"llbc.prehandler = pyllbc_prehandler\n"
"\n"
"def pyllbc_unify_prehandler(handler):\n"
"    \"\"\"\n"
"    Decorate packet unify pre-handler class, once decorate, library will use the class to unify pre-handle packet.\n"
"    Handler must has handle() method or has __call__() method.\n"
"    \"\"\"\n"
"    RegCls = llbc.inl.SvcRegInfo\n"
"    RegsHolder = llbc.inl.SvcRegsHolder\n"
"    reg = pyllbc_extractreg(handler, RegCls.UnifyPreHandler)\n"
"    RegsHolder.update(reg)\n"
"    return handler\n"
"\n"
"llbc.unify_prehandler = pyllbc_unify_prehandler\n"
"\n"
"def pyllbc_exc_handler(*opcodes):\n"
"    \"\"\"\n"
"    Decorate packet handler exception handler class, once decorate, library will use the class to pre-handle packet.\n"
"    Handler must has __call__() method.\n"
"    \"\"\"\n"
"    # not callable, try parse opcodes\n"
"    def generator(handler):\n"
"        RegCls = llbc.inl.SvcRegInfo\n"
"        RegsHolder = llbc.inl.SvcRegsHolder\n"
"\n"
"        reg = pyllbc_extractreg(handler, RegCls.ExcHandler)\n"
"\n"
"        converted = __pyllbc_normalize_opcodes(opcodes)\n"
"        RegsHolder.update(reg.add_exc_hldropcodes(*converted))\n"
"        return handler\n"
"    return generator\n"
"\n"
"llbc.exc_handler = pyllbc_exc_handler\n"
"\n"
"def pyllbc_dft_exc_handler(handler):\n"
"    \"\"\"\n"
"    Decroate packet-handler's default exception handler class, once decorate, library will use the class to process \n"
"    packet-handler's exception.\n"
"    Handler must has __call__() method.\n"
"    \"\"\"\n"
"    RegCls = llbc.inl.SvcRegInfo\n"
"    RegsHolder = llbc.inl.SvcRegsHolder\n"
"    reg = pyllbc_extractreg(handler, RegCls.DftExcHandler)\n"
"    RegsHolder.update(reg)\n"
"    return handler\n"
"\n"
"llbc.dft_exc_handler = pyllbc_dft_exc_handler\n"
"\n"
"def pyllbc_dft_exc_prehandler(handler):\n"
"    \"\"\"\n"
"    Decroate packet-prehandler's default exception handler class, once decorate, library will use the class to\n"
"    process packet-prehandler's exception.\n"
"    Handler must has __call__() method.\n"
"    \"\"\"\n"
"    RegCls = llbc.inl.SvcRegInfo\n"
"    RegsHolder = llbc.inl.SvcRegsHolder\n"
"    reg = pyllbc_extractreg(handler, RegCls.DftExcPreHandler)\n"
"    RegsHolder.update(reg)\n"
"    return handler\n"
"\n"
"llbc.dft_exc_prehandler = pyllbc_dft_exc_prehandler\n"
"\n"
"def pyllbc_exc_prehandler(*opcodes):\n"
"    \"\"\"\n"
"    Decorate packet prehandler exception handler class, once decorate, library will use the class to pre-handle packet.\n"
"    Handler must has __call__() method.\n"
"    \"\"\"\n"
"    def generator(handler):\n"
"        RegCls = llbc.inl.SvcRegInfo\n"
"        RegsHolder = llbc.inl.SvcRegsHolder\n"
"        reg = pyllbc_extractreg(handler, RegCls.ExcPreHandler)\n"
"\n"
"        converted = __pyllbc_normalize_opcodes(opcodes)\n"
"        RegsHolder.update(reg.add_exc_prehldropcodes(*converted))\n"
"        return handler\n"
"    return generator\n"
"\n"
"llbc.exc_prehandler = pyllbc_exc_prehandler\n"
"\n"
"def pyllbc_construct_STATUS_WRAPPER_ASSIGNMENTS():\n"
"    assigned = set(functools.WRAPPER_ASSIGNMENTS)\n"
"    assigned.remove('__name__')\n"
"    return assigned\n"
"llbc.STATUS_WRAPPER_ASSIGNMENTS = pyllbc_construct_STATUS_WRAPPER_ASSIGNMENTS()\n"
"\n"
"def pyllbc_status_wrapper(wrapped,\n"
"        assigned = llbc.STATUS_WRAPPER_ASSIGNMENTS,\n"
"        updated = functools.WRAPPER_UPDATES):\n"
"    \"\"\"\n"
"    LLBC library status code handler wrapper decorator, use to decorate status code handler.\n"
"    \"\"\"\n"
"    return functools.partial(functools.update_wrapper, wrapped=wrapped,\n"
"            assigned=assigned, updated=updated)\n"
"\n"
"llbc.status_wrapper = pyllbc_status_wrapper\n"
"\n"
"def pyllbc_status(*status):\n"
"    \"\"\"\n"
"    Decorate packet-handler class's status handler, library will use the method to handle packet.\n"
"    Status handler must callable.\n"
"    TODO: Will implement\n"
"    \"\"\"\n"
"    pass\n"
"\n"
"llbc.status = pyllbc_status\n"
"\n"
"def pyllbc_forsend(opcode):\n"
"    \"\"\"\n"
"    Decorate coder clas, once decorate, library will use the class to encode packet.\n"
"    \"\"\"\n"
"    # callable opcode, it means opcode is coder\n"
"    if callable(opcode):\n"
"        hashed_opcode = llbc.inl.HashString(opcode.__name__)\n"
"        return pyllbc_forsend(hashed_opcode)(opcode)\n"
"\n"
"    # not callable, it means opcode is real opcode, parse it\n"
"    def generator(coder):\n"
"        RegCls = llbc.inl.SvcRegInfo\n"
"        RegsHolder = llbc.inl.SvcRegsHolder\n"
"\n"
"        reg = pyllbc_extractreg(coder, RegCls.Coder)\n"
"        reg.enopcode = opcode.OP if hasattr(opcode, 'OP') else \\\n"
"            (opcode.OPCODE if hasattr(opcode, 'OPCODE') else opcode)\n"
"        RegsHolder.update(reg)\n"
"        return coder\n"
"\n"
"    return generator\n"
"\n"
"llbc.forsend = pyllbc_forsend\n"
"\n"
"def pyllbc_forrecv(*opcodes):\n"
"    \"\"\"\n"
"    Decorate coder class, once decorate, library will use the class to decode packet.\n"
"    \"\"\"\n"
"    # opcodes[0] callable, it means opcodes[0] is coder\n"
"    if len(opcodes) == 1 and callable(opcodes[0]):\n"
"        hashed_opcode = llbc.inl.HashString(opcodes[0].__name__)\n"
"        return pyllbc_forrecv(hashed_opcode)(opcodes[0])\n"
"\n"
"    # not callable, parse opcode\n"
"    def generator(coder):\n"
"        RegCls = llbc.inl.SvcRegInfo\n"
"        RegsHolder = llbc.inl.SvcRegsHolder\n"
"\n"
"        converted = [(opcode.OP if hasattr(opcode, 'OP') else \\\n"
"                (opcode.OPCODE if hasattr(opcode, 'OPCODE') else opcode)) for opcode in opcodes]\n"
"        reg = pyllbc_extractreg(coder, RegCls.Coder)\n"
"        RegsHolder.update(reg.add_deocodes(*converted))\n"
"        return coder\n"
"    return generator\n"
"\n"
"llbc.forrecv = pyllbc_forrecv\n"
"\n"
"def pyllbc_packet(opcode):\n"
"    \"\"\"\n"
"    Decorate coder class, once decorate, library will use the class to encode & decode packet.\n"
"    \"\"\"\n"
"    # callable opcode, means this opcode is coder\n"
"    if callable(opcode):\n"
"        hashed_opcode = llbc.inl.HashString(opcode.__name__)\n"
"        return pyllbc_packet(hashed_opcode)(opcode)\n"
"\n"
"    # opcode not callable, parse opcode\n"
"    def generator(coder):\n"
"        pyllbc_forsend(opcode)(coder)\n"
"        recv_opcodes = (opcode, ) if opcode is not None else tuple()\n"
"        pyllbc_forrecv(*recv_opcodes)(coder)\n"
"        return coder\n"
"    return generator\n"
"\n"
"llbc.packet = pyllbc_packet\n"
"\n"
"def pyllbc_bindto(*svcs):\n"
"    \"\"\"\n"
"    Specific packet-handler/coder/facade bind to which service.\n"
"    \"\"\"\n"
"    def generator(cls):\n"
"        RegCls = llbc.inl.SvcRegInfo\n"
"        RegsHolder = llbc.inl.SvcRegsHolder\n"
"\n"
"        reg = pyllbc_extractreg(cls, RegCls.UnSpecific)\n"
"        RegsHolder.update(reg.add_svcs(*svcs))\n"
"        return cls\n"
"\n"
"    return generator\n"
"\n"
"llbc.bindto = pyllbc_bindto\n"
"\n"
"def pyllbc_facade(cls):\n"
"    \"\"\"\n"
"    Decorate facade class, once decorate, in startup, llbc library \n"
"    will auto create facade object and register to specific services.\n"
"    \"\"\"\n"
"    RegCls = llbc.inl.SvcRegInfo\n"
"    RegsHolder = llbc.inl.SvcRegsHolder\n"
"\n"
"    reg = pyllbc_extractreg(cls, RegCls.UnSpecific)\n"
"    reg.asfacade = True\n"
"    RegsHolder.update(reg)\n"
"    return cls\n"
"\n"
"llbc.facade = pyllbc_facade\n"
"\n"
)));
        _scripts.insert(::std::make_pair("Service.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import sys as _sys\n"
"import types as _types\n"
"from time import time as _pyllbc_time\n"
"from time import sleep as _pyllbc_sleep\n"
"from weakref import ref as _ref\n"
"\n"
"import llbc\n"
"from llbc import Packet\n"
"\n"
"\n"
"class pyllbcSvcExcHandler(object):\n"
"    \"\"\"\n"
"    pyllbc service exception handler class encapsulation.\n"
"    \"\"\"\n"
"\n"
"    # The handler type enumeration\n"
"    BeginHandlerType = 0\n"
"    Subscribe = BeginHandlerType + 0\n"
"    PreSubscribe = BeginHandlerType + 1\n"
"\n"
"    InvalidateHandlerType = BeginHandlerType + 2\n"
"\n"
"    @classmethod\n"
"    def type_2_str(cls, ty):\n"
"        if ty == cls.Subscribe:\n"
"            return 'Subscribe'\n"
"        elif ty == cls.PreSubscribe:\n"
"            return 'PreSubscribe'\n"
"        else:\n"
"            return 'Unknown'\n"
"\n"
"    @classmethod\n"
"    def is_validate_handler_type(cls, ty):\n"
"        return cls.BeginHandlerType <= ty < cls.InvalidateHandlerType\n"
"\n"
"    @property\n"
"    def real_handler(self):\n"
"        return self._handler\n"
"\n"
"    def __init__(self, ty, svc, handler):\n"
"        if not self.is_validate_handler_type(ty):\n"
"            raise llbc.error('invalidate handler type: {}'.format(ty))\n"
"        elif svc is None or (handler is None or not callable(handler)):\n"
"            raise llbc.error('service[{}] invalidate or handler[{}] invalidate'.format(svc, handler))\n"
"\n"
"        self._ty = ty\n"
"        self._svc = _ref(svc)\n"
"        self._handler = handler\n"
"\n"
"    def __call__(self, packet):\n"
"        try:\n"
"            return self._handler(packet)\n"
"        except Exception, e:\n"
"            op = packet.opcode\n"
"\n"
"            ty = self._ty\n"
"            svc = self._svc()\n"
"            if ty == self.Subscribe:\n"
"                exc_handler = svc._subscribe_exc_handlers.get(op)\n"
"                if exc_handler is None:\n"
"                    exc_handler = svc._dft_subscribe_exc_handler\n"
"            elif ty == self.PreSubscribe:\n"
"                exc_handler = svc._presubscribe_exc_handlers.get(op)\n"
"                if exc_handler is None:\n"
"                    exc_handler = svc._dft_presubscribe_exc_handler\n"
"            else:\n"
"                exc_handler = None\n"
"\n"
"            if exc_handler is not None:\n"
"                tb = _sys.exc_info()[2]\n"
"                exc_handler(packet, tb, e)\n"
"            else:\n"
"                raise\n"
"\n"
"    def __repr__(self):\n"
"        return self._handler.__repr__()\n"
"\n"
"    def __str__(self):\n"
"        return self._handler.__str__()\n"
"\n"
"    def to_string(self):\n"
"        handler_type = self.type_2_str(self._ty)\n"
"        return 'handler type: {}, handler: {}, registered in service: [{}]'.format(handler_type, self._handler, self._svc())\n"
"\n"
"llbc.inl.SvcExcHandler = pyllbcSvcExcHandler \n"
"\n"
"class pyllbcServiceMetaCls(type):\n"
"    \"\"\"\n"
"    pyllbc service meta class define.\n"
"    \"\"\"\n"
"    def __init__(cls, name, bases, attrs):\n"
"        super(pyllbcServiceMetaCls, cls).__init__(name, bases, attrs)\n"
"\n"
"    def __getitem__(cls, item):\n"
"        return cls._svcs_dict[item]\n"
"\n"
"    def __setitem__(cls, item, value):\n"
"        raise NotImplementedError('Service __setitem__ method not implemented')\n"
"\n"
"    def __delitem__(cls, item):\n"
"        svc = cls[item]\n"
"        if svc.started:\n"
"            svc.stop()\n"
"        else:\n"
"            svc._will_dels.update((svc, ))\n"
"\n"
"        if not cls._scheduling:\n"
"            cls._procwilldelsvcs()\n"
"\n"
"    def __getattr__(cls, key):\n"
"        svc = cls._svcs_dict.get(key)\n"
"        if svc is not None:\n"
"            return svc\n"
"        else:\n"
"            return super(pyllbcServiceMetaCls, cls).__getattr__(key)\n"
"\n"
"    def __setattr__(cls, key, value):\n"
"        if key in cls._svcs_dict:\n"
"            raise llbc.error('attribute [{}] already used by service name, could not override'.format(key))\n"
"        else:\n"
"            super(pyllbcServiceMetaCls, cls).__setattr__(key, value)\n"
"\n"
"    def __delattr__(cls, key):\n"
"        if key in cls._svcs_dict:\n"
"            cls.__delitem__(key)\n"
"        else:\n"
"            super(pyllbcServiceMetaCls, cls).__delattr__(key)\n"
"\n"
"    def __iter__(cls):\n"
"        return cls._svcs_list.__iter__()\n"
"\n"
"    def __len__(cls):\n"
"        return cls._svcs_list.__len__()\n"
"\n"
"    @property\n"
"    def scheduling(cls):\n"
"        return cls._scheduling\n"
"\n"
"llbc.ServiceMetaClass = pyllbcServiceMetaCls\n"
"\n"
"class pyllbcService(object):\n"
"    \"\"\"\n"
"    pyllbc library service class encapsulation.\n"
"    \"\"\"\n"
"    # set serivce meta class.\n"
"    __metaclass__ = pyllbcServiceMetaCls\n"
"\n"
"    # service type define.\n"
"    NORMAL = llbc.inl.SVC_TYPE_NORMAL # Normalize type service.\n"
"    RAW = llbc.inl.SVC_TYPE_RAW # Raw type service.\n"
"\n"
"    # service codec strategies define.\n"
"    CODEC_JSON = llbc.inl.SVC_CODEC_JSON\n"
"    CODEC_BINARY = llbc.inl.SVC_CODEC_BINARY\n"
"\n"
"    # FPS limit values define.\n"
"    MIN_FPS = llbc.inl.SVC_MIN_FPS\n"
"    MAX_FPS = llbc.inl.SVC_MAX_FPS\n"
"\n"
"    # services startup limit\n"
"    MAX_COUNT = llbc.inl.SVC_MAX_COUNT\n"
"\n"
"    # ----------------------------------------------------------------------\n"
"    # internal uses:\n"
"    # all services list & dict\n"
"    _svcs_list = []\n"
"    _svcs_dict = {}\n"
"\n"
"    # service schedule helper data structures.\n"
"    _will_dels = set()\n"
"    _scheduling = False\n"
"    _descheduling = False\n"
"\n"
"    # frame exception handler.\n"
"    _frame_exc_handler = None\n"
"    # ----------------------------------------------------------------------\n"
"\n"
"    def __init__(self, svcname, svctype=llbc.inl.SVC_TYPE_NORMAL):\n"
"        \"\"\"\n"
"        Create new service\n"
"        :param svctype: the service type, see service type enumeration.\n"
"        :param svcname: the service name, must be not empty.\n"
"        \"\"\"\n"
"        if isinstance(svcname, unicode):\n"
"            svcname = svcname.encode('utf-8')\n"
"\n"
"        if not isinstance(svcname, str):\n"
"            raise llbc.error('service name must str type')\n"
"        elif not svcname:\n"
"            raise llbc.error('service name must be not empty')\n"
"\n"
"        if self.isgonetolimit():\n"
"            raise llbc.error('service count is gone to limit')\n"
"\n"
"        self._svcname = svcname\n"
"        self._svctype = svctype\n"
"\n"
"        self._addsvc(self)\n"
"        self._c_obj = llbc.inl.NewService(self, svctype, svcname)\n"
"        self._svcid = llbc.inl.GetServiceId(self._c_obj)\n"
"\n"
"        self._encoders = {}\n"
"        self._facades = {}\n"
"\n"
"        cobj = self._c_obj\n"
"        self._fps = llbc.inl.GetServiceFPS(cobj)\n"
"        self._frameinterval = llbc.inl.GetServiceFrameInterval(cobj)\n"
"\n"
"        self._last_schedule_time = 0\n"
"        self._started = False\n"
"\n"
"        self._terminating = False\n"
"        self._terminated = False\n"
"\n"
"        self._subscribe_exc_handlers = dict()  # key: opcode, value: exception handler\n"
"        self._presubscribe_exc_handlers = dict()  # key: opcode, value: exception handler\n"
"\n"
"        self._dft_subscribe_exc_handler = None \n"
"        self._dft_presubscribe_exc_handler = None\n"
"\n"
"    def __del__(self):\n"
"        if hasattr(self, '_c_obj'):\n"
"            llbc.inl.DelService(self._c_obj)\n"
"\n"
"    def __str__(self):\n"
"        return 'objid:{}, type:{}, name:{}, started:{}, scheduling:{}'.format(\n"
"                id(self), self.typestr, self._svcname, self._started, self.scheduling)\n"
"\n"
"    def __repr__(self):\n"
"        return \"Service('{}', Service.{})\".format(self.name, self.typestr)\n"
"\n"
"    @property\n"
"    def type(self):\n"
"        return self._svctype\n"
"\n"
"    @property\n"
"    def typestr(self):\n"
"        return llbc.inl.GetServiceTypeStr(self._svctype)\n"
"\n"
"    @property\n"
"    def id(self):\n"
"        return self._svcid\n"
"\n"
"    @property\n"
"    def name(self):\n"
"        return self._svcname\n"
"\n"
"    @property\n"
"    def started(self):\n"
"        return self._started\n"
"\n"
"    @property\n"
"    def fps(self):\n"
"        return self._fps\n"
"\n"
"    @fps.setter\n"
"    def fps(self, newfps):\n"
"        llbc.inl.SetServiceFPS(self._c_obj, newfps)\n"
"\n"
"        self._fps = newfps\n"
"        self._frameinterval = llbc.inl.GetServiceFrameInterval(self._c_obj)\n"
"\n"
"    @property\n"
"    def frameinterval(self):\n"
"        return self._frameinterval\n"
"\n"
"    @property\n"
"    def codec(self):\n"
"        return llbc.inl.GetServiceCodec(self._c_obj)\n"
"\n"
"    @codec.setter\n"
"    def codec(self, c):\n"
"        llbc.inl.SetServiceCodec(self._c_obj, c)\n"
"\n"
"    def suppress_codernotfound_warning(self):\n"
"        \"\"\"\n"
"        Suppress all coder not found warning.\n"
"        If suppressed, packet handler received packet.data type is llbc.Stream type.\n"
"        \"\"\"\n"
"        llbc.inl.SuppressServiceCoderNotFoundWarning(self._c_obj)\n"
"\n"
"    def start(self, pollercount=1):\n"
"        \"\"\"\n"
"        Start service.\n"
"        :param pollercount: the poller count, default is 1.\n"
"        \"\"\"\n"
"        self._startcheck()\n"
"\n"
"        self._autoregist()\n"
"        if self not in self.__class__._svcs_list:\n"
"            self._addsvc(self)\n"
"\n"
"        llbc.inl.StartService(self._c_obj, pollercount)\n"
"        self._started = True\n"
"\n"
"    @classmethod\n"
"    def set_frame_exc_handler(cls, exc_handler):\n"
"        \"\"\"\n"
"        Set service per-frame exception handler(class method).\n"
"        handler can be function or method or callable object.\n"
"        handler method proto-type:\n"
"            the_frame_exception_handler(service_obj, traceback_obj, exception_value)\n"
"                service_obj: the service instance, this params maybe None if raised in timer.\n"
"                traceback_obj: the traceback type instance.\n"
"                error_value: the exception value.\n"
"        \"\"\"\n"
"        if exc_handler is None:\n"
"            cls._frame_exc_handler = None\n"
"        elif not callable(exc_handler):\n"
"            raise llbc.error('{} not callable'.format(exc_handler))\n"
"        else:\n"
"            cls._frame_exc_handler = exc_handler\n"
"\n"
"    def stop(self):\n"
"        \"\"\"\n"
"        Stop service\n"
"        \"\"\"\n"
"        if not self._started:\n"
"            return None\n"
"\n"
"        self._started = False\n"
"        self._terminating = True\n"
"\n"
"        try:\n"
"            llbc.inl.StopService(self._c_obj)\n"
"        except BaseException, e:\n"
"            raise\n"
"        finally:\n"
"            self.__class__._will_dels.update((self, ))\n"
"\n"
"    @classmethod\n"
"    def get(cls, svcname):\n"
"        \"\"\"\n"
"        Get service by name\n"
"        \"\"\"\n"
"        return cls._svcs_dict.get(svcname)\n"
"\n"
"    @classmethod\n"
"    def isgonetolimit(cls):\n"
"        return True if len(cls._svcs_list) >= cls.MAX_COUNT else False\n"
"\n"
"    @classmethod\n"
"    def schedule(cls, schedule_time=0, idle_sleep=True):\n"
"        \"\"\"\n"
"        Service mainloop\n"
"        :param schedule_time: specific schedule time, in seconds, if less than or equal to 0, schedule or return immediately.\n"
"        :param idle_sleep: at one schedule operation, if service check has idle time, will sleep if idle_sleep set to True, otherwise not sleep.\n"
"        \"\"\"\n"
"        if cls._scheduling:\n"
"            raise llbc.error('Service in scheduling, not allow to reschedule')\n"
"        cls._scheduling = True\n"
"\n"
"        svcs = cls._svcs_list\n"
"        schedule_interval = 1.0 / cls.MAX_FPS\n"
"        svc_mainloop = llbc.inl.ServiceMainLoop\n"
"        update_timers = llbc.inl.PyTimerUpdateAllTimers\n"
"        inst_errhooker = llbc.inl.InstallErrHooker\n"
"        uninst_errhooker = llbc.inl.UninstallErrHooker\n"
"        clear_hookederrors = llbc.inl.ClearHookedErrors\n"
"\n"
"        try:\n"
"            inst_errhooker()\n"
"            cls._procwilldelsvcs()\n"
"\n"
"            if schedule_time > 0:\n"
"                schedule_beg = _pyllbc_time()\n"
"\n"
"            while True:\n"
"                if idle_sleep:\n"
"                    scheduleonce_beg = _pyllbc_time()\n"
"\n"
"                clear_hookederrors()\n"
"                try:\n"
"                    for svc in svcs:\n"
"                        if not svc._started:\n"
"                            continue\n"
"    \n"
"                        svc_beg = _pyllbc_time()\n"
"                        if svc_beg - svc._last_schedule_time >= svc._frameinterval:\n"
"                            cobj = svc._c_obj\n"
"                            try:\n"
"                                svc_mainloop(cobj)\n"
"                            except Exception, e:\n"
"                                frame_exc_handler = cls._frame_exc_handler\n"
"                                if frame_exc_handler is not None:\n"
"                                    tb = _sys.exc_info()[2]\n"
"                                    frame_exc_handler(svc, tb, e)\n"
"                                else:\n"
"                                    raise\n"
"                            finally:\n"
"                                svc._last_schedule_time = svc_beg\n"
"\n"
"                        if cls._procpendingdeschedule():\n"
"                            return\n"
"                        \n"
"                    update_timers()\n"
"                    if cls._procpendingdeschedule():\n"
"                        return\n"
"                except Exception, e:\n"
"                    frame_exc_handler = cls._frame_exc_handler\n"
"                    if frame_exc_handler is not None:\n"
"                        tb = _sys.exc_info()[2]\n"
"                        frame_exc_handler(None, tb, e)\n"
"                    else:\n"
"                        raise\n"
"                finally:\n"
"                    cls._procwilldelsvcs()\n"
"\n"
"                now = _pyllbc_time()\n"
"                if schedule_time > 0:\n"
"                    if now - schedule_beg >= schedule_time:\n"
"                        break\n"
"    \n"
"                if idle_sleep:\n"
"                    elapsed = now - scheduleonce_beg\n"
"                    if elapsed < 0:\n"
"                        continue\n"
"                    elif elapsed < schedule_interval:\n"
"                        _pyllbc_sleep(schedule_interval - elapsed)\n"
"        except BaseException, e:\n"
"            raise\n"
"        finally:\n"
"            uninst_errhooker()\n"
"            cls._scheduling = False\n"
"\n"
"    @classmethod\n"
"    def deschedule(cls):\n"
"        if not cls._scheduling:\n"
"            return\n"
"        elif cls._descheduling:\n"
"            return\n"
"\n"
"        cls._descheduling = True\n"
"\n"
"    @property\n"
"    def scheduling(self):\n"
"        return self.__class__.scheduling\n"
"\n"
"    def registerfacade(self, facade):\n"
"        \"\"\"\n"
"        Register facade.\n"
"            facade methods(all methods are optional):\n"
"                oninitialize(self, ev): service initialize handler.\n"
"                    ev.svc: service object.\n"
"                ondestroy(self, ev): service destroy handler.\n"
"                    ev.svc: service object.\n"
"                onstart(self, ev): service start handler.\n"
"                    ev.svc: service object.\n"
"                onstop(self, ev): service stop handler.\n"
"                    ev.svc: service object.\n"
"                onupdate(self, ev): service per-frame update handler.\n"
"                    ev.svc: service object.\n"
"                onidle(self, ev): service per-frame idle handler.\n"
"                    ev.svc: service object.\n"
"                    ev.idletime: idle time, float type, in seconds.\n"
"                onsessioncreate(self, ev): session create handler.\n"
"                    ev.svc: service object.\n"
"                    ev.islisten: is listen session or not.\n"
"                    ev.session_id: session Id.\n"
"                    ev.local_ip: local ip address.\n"
"                    ev.local_port: local port number.\n"
"                    ev.peer_ip: peer ip address.\n"
"                    ev.peer_port: peer port number.\n"
"                onsessiondestroy(self, ev): session destroy handler.\n"
"                    ev.svc: service object.\n"
"                    ev.session_id: session Id.\n"
"                    ev.reason: destroy reason.\n"
"                    ev.destroyed_from_service: destroyed from service flag.\n"
"                    ev.local_ip: local ip address.\n"
"                    ev.local_port: local port number.\n"
"                    ev.peer_ip: peer ip address.\n"
"                    ev.peer_port: peer port number.\n"
"                    ev.socket: socket file descripter.\n"
"                    ev.errno: error number(only available when ev.destroyed_from_service is True).\n"
"                    ev.sub_errno: sub error number(only available when ev.destroyed_from_service is True).\n"
"                onasyncconnresult(self, ev): async-connect result handler.\n"
"                    ev.svc: service object.\n"
"                    ev.peer_ip: peer ip address.\n"
"                    ev.peer_port: peer port number.\n"
"                    ev.connected: connected flag.\n"
"                    ev.reason: reason describe.\n"
"                onprotoreport(self, ev): protocol report.\n"
"                    ev.svc: service object.\n"
"                    ev.report_layer: which layer protocol reported.\n"
"                    ev.report_level: report event level(DEBUG, INFO, WARN, ERROR).\n"
"                    ev.report_msg: report message.\n"
"                    ev.session_id: report session_id(optional, maybe is 0).\n"
"                onunhandledpacket(self, ev): unhandled packet.\n"
"                    ev.svc: service object.\n"
"					ev.session_id: packet session Id.\n"
"                    ev.opcode: packet opcode.\n"
"					ev.packet: packet object.\n"
"        \"\"\"\n"
"        if hasattr(facade, '__bases__') and llbc.ischild(facade, type):\n"
"            raise llbc.error('facade could not be type(or derived from type) instance, facade:{}'.format(facade))\n"
"        elif isinstance(facade, type):\n"
"            raise llbc.error('facade could not be class type object, facade: {}'.format(facade))\n"
"        else:\n"
"            if isinstance(facade, _types.FunctionType):\n"
"                raise llbc.error('facade could not be a function, facade: {}'.format(facade))\n"
"            elif isinstance(facade, _types.MethodType):\n"
"                raise llbc.error('facade could not be a method(included bound and unbound), facade: {}'.format(facade))\n"
"\n"
"        llbc.inl.RegisterFacade(self._c_obj, facade)\n"
"        self._facades.update({facade.__class__: facade})\n"
"\n"
"    def getfacade(self, cls):\n"
"        \"\"\"\n"
"        Get facade by facade class.\n"
"        \"\"\"\n"
"        return self._facades.get(cls)\n"
"\n"
"    def registerencoder(self, opcode, encoder):\n"
"        \"\"\"\n"
"        Register specific opcode's encoder(only available in CODEC_BINARY codec mode).\n"
"        \"\"\"\n"
"        if not hasattr(encoder, 'encode') or not callable(encoder.encode):\n"
"            raise llbc.error('invalid encoder, opcode: {}, encoder: {}'.format(opcode, encoder))\n"
"        elif encoder in self._encoders:\n"
"            raise llbc.error('encoder duplicate registered, opcode: {}, encoder: {}'.format(opcode, encoder))\n"
"\n"
"        self._encoders.update({encoder:opcode})\n"
"\n"
"    def registerdecoder(self, opcode, coder):\n"
"        \"\"\"\n"
"        Register specific opcode's decoder(only available in CODEC_BINARY codec mode).\n"
"        Note: must raw types(eg:int, long, float, str, bytearray, unicode...) or exist follow methods' class:\n"
"              decode(self, stream): decode data from stream.\n"
"        \"\"\"\n"
"\n"
"        llbc.inl.RegisterCodec(self._c_obj, opcode, coder)\n"
"\n"
"    def listen(self, ip, port):\n"
"        \"\"\"\n"
"        Listen in specified address.\n"
"        :return: the session id.\n"
"        \"\"\"\n"
"        return llbc.inl.Listen(self._c_obj, ip, port)\n"
"\n"
"    def connect(self, ip, port):\n"
"        \"\"\"\n"
"        Connect to peer.\n"
"        :return: the session id.\n"
"        \"\"\"\n"
"        return llbc.inl.Connect(self._c_obj, ip, port)\n"
"\n"
"    def asyncconn(self, ip, port):\n"
"        \"\"\"\n"
"        Asynchronous connect to peer(non-blocking, direct return)\n"
"        \"\"\"\n"
"        llbc.inl.AsyncConn(self._c_obj, ip, port)\n"
"\n"
"    def removesession(self, session_id, reason='', strict=False):\n"
"        \"\"\"\n"
"        Remove session\n"
"        :param session_id: the will remove session Id.\n"
"        :param reason: remove reason, default is empty string.\n"
"        :param strict: strict mode flag, default is false, if set to true and the session not exist or already removed, will raise an exception.\n"
"        \"\"\"\n"
"        llbc.inl.RemoveSession(self._c_obj, session_id, reason, strict)\n"
"\n"
"    def send(self, session_id, data, opcode=None, status=0):\n"
"        \"\"\"\n"
"        Send data to specific session\n"
"        \"\"\"\n"
"        cls = self.__class__\n"
"        svc_type = self._svctype\n"
"        if svc_type == cls.NORMAL:\n"
"            if opcode is None:\n"
"                opcode = self._encoders.get(data.__class__)\n"
"                if opcode is None:\n"
"                    raise llbc.error('will send data not specific opcode(forgot use \"@llbc.forsend\" decorator?), '\n"
"                            'data: {}, type: {}'.format(data, data.__class__))\n"
"        else:\n"
"            opcode = 0\n"
"        \n"
"        # Support using packet as session_id to send packet.\n"
"        if isinstance(session_id, Packet):\n"
"            session_id = session_id.session_id\n"
"\n"
"        llbc.inl.SendData(self._c_obj, session_id, opcode, data, status)\n"
"\n"
"    def multicast(self, session_ids, data, opcode=None, status=0):\n"
"        \"\"\"\n"
"        Multicast message\n"
"        \"\"\"\n"
"        llbc.inl.Multicast(self._c_obj, session_ids, opcode, data, status)\n"
"\n"
"    def broadcast(self, data, opcode=None, status=0):\n"
"        \"\"\"\n"
"        Broadcast message\n"
"        \"\"\"\n"
"        llbc.inl.Broadcast(self._c_obj, opcode, data, status)\n"
"\n"
"    def subscribe(self, opcode, handler, exc_handler=None):\n"
"        \"\"\"\n"
"        Subscribe specific opcode's message.\n"
"          handler search order:\n"
"            1> callable search(included impl __call__() meth object, bound self method, function).\n"
"            2> handle() method search.\n"
"          handler(function/method) proto-type.\n"
"            >>>> YourCls.handle(self, packet): pass\n"
"            >>>> YourCls.__call__(self, packet): pass\n"
"            >>>> def handle(packet): pass\n"
"          packet properties describe: \n"
"            packet.svc: service\n"
"            packet.opcode: opcode\n"
"            packet.status: status\n"
"            packet.session_id: session Id\n"
"            packet.local_ip: local ip\n"
"            packet.local_port: local port\n"
"            packet.peer_ip: peer ip\n"
"            packet.peer_port: peer port\n"
"            packet.data: <the data>\n"
"        \"\"\"\n"
"        _WH = pyllbcSvcExcHandler\n"
"        wrap_handler = _WH(_WH.Subscribe, self, handler)\n"
"\n"
"        llbc.inl.Subscribe(self._c_obj, opcode, wrap_handler)\n"
"\n"
"        if exc_handler is not None:\n"
"            self.set_subscribe_exc_handler(opcode, exc_handler)\n"
"\n"
"    def set_subscribe_exc_handler(self, opcode, exc_handler):\n"
"        \"\"\"\n"
"        Set the packet handler's exception handler.\n"
"        handler proto-type:\n"
"            the_packet_exception_handler(packet, traceback_obj, exception_value)\n"
"                packet: the packet object.\n"
"                traceback_obj: the traceback type instance.\n"
"                error_value: the exception value.\n"
"        \"\"\"\n"
"        if exc_handler is None:\n"
"            if opcode in self._subscribe_exc_handlers:\n"
"                del self._subscribe_exc_handlers[opcode]\n"
"        elif not callable(exc_handler):\n"
"            raise llbc.error('{} not callable'.format(exc_handler))\n"
"        else:\n"
"            self._subscribe_exc_handlers[opcode] = exc_handler\n"
"\n"
"    def set_default_subscribe_exc_handler(self, dft_exc_handler):\n"
"        \"\"\"\n"
"        Set the packet handler's default exception handler.\n"
"        handler proto-type:\n"
"            the_packet_exception_handler(packet, traceback_obj, exception_value)\n"
"                packet: the packet object.\n"
"                traceback_obj: the traceback type instance.\n"
"                error_value: the exception value.\n"
"        \"\"\"\n"
"        if dft_exc_handler is None:\n"
"            self._dft_subscribe_exc_handler = None\n"
"        elif not callable(dft_exc_handler):\n"
"            raise llbc.error('{} not callable'.format(dft_exc_handler))\n"
"        else:\n"
"            self._dft_subscribe_exc_handler = dft_exc_handler\n"
"\n"
"    def presubscribe(self, opcode, prehandler, exc_handler=None):\n"
"        \"\"\"\n"
"        PreSubscribe specific opcode's message.\n"
"        For get more informations, see subscribe() method.\n"
"        \"\"\"\n"
"        _WH = pyllbcSvcExcHandler\n"
"        wrap_prehandler = _WH(_WH.PreSubscribe, self, prehandler)\n"
"\n"
"        llbc.inl.PreSubscribe(self._c_obj, opcode, wrap_prehandler)\n"
"\n"
"        if exc_handler is not None:\n"
"            self.set_presubscribe_exc_handler(opcode, exc_handler)\n"
"\n"
"    def set_presubscribe_exc_handler(self, opcode, exc_handler):\n"
"        \"\"\"\n"
"        Set the packet pre-handler's exception handler.\n"
"        handler proto-type:\n"
"            the_packet_exception_handler(packet, traceback_obj, exception_value)\n"
"                packet: the packet object.\n"
"                traceback_obj: the traceback type instance.\n"
"                error_value: the exception value.\n"
"        \"\"\"\n"
"        if exc_handler is None:\n"
"            if opcode in self._presubscribe_exc_handlers:\n"
"                del self._presubscribe_exc_handlers[opcode]\n"
"        elif not callable(exc_handler):\n"
"            raise llbc.error('{} not callable'.format(exc_handler))\n"
"        else:\n"
"            self._presubscribe_exc_handlers[opcode] = exc_handler\n"
"\n"
"    def set_default_presubscribe_exc_handler(self, dft_exc_handler):\n"
"        \"\"\"\n"
"        Set the packet pre-handler's default exception handler.\n"
"        handler proto-type:\n"
"            the_packet_exception_handler(packet, traceback_obj, exception_value)\n"
"                packet: the packet object.\n"
"                traceback_obj: the traceback type instance.\n"
"                error_value: the exception value.\n"
"        \"\"\"\n"
"        if dft_exc_handler is None:\n"
"            self._dft_presubscribe_exc_handler = None\n"
"        elif not callable(dft_exc_handler):\n"
"            raise llbc.error('{} not callable'.format(dft_exc_handler))\n"
"        else:\n"
"            self._dft_presubscribe_exc_handler = dft_exc_handler\n"
"\n"
"    def unify_presubscribe(self, prehandler):\n"
"        \"\"\"\n"
"        Unify PreSubscribe message.\n"
"        For get more informations, see subscribe() method.\n"
"        \"\"\"\n"
"        llbc.inl.UnifyPreSubscribe(self._c_obj, prehandler)\n"
"\n"
"    def post(self, cble):\n"
"        \"\"\"\n"
"        Post callable object to service, service will lazy call it.\n"
"        \"\"\"\n"
"        llbc.inl.Post(self._c_obj, cble)\n"
"\n"
"    def _startcheck(self):\n"
"        if self._started:\n"
"            raise llbc.error('service object already started')\n"
"        elif self._terminating:\n"
"            raise llbc.error('service object terminating')\n"
"\n"
"    def _autoregist(self):\n"
"        llbc.inl.SvcRegsHolder.decorate(self)\n"
"        llbc.inl.SvcRegsHolder.decorate_cls()\n"
"\n"
"    @classmethod\n"
"    def _addsvc(cls, svc):\n"
"        if svc.name in cls._svcs_dict:\n"
"            raise llbc.error('service name repeat, name: {}'.format(svc.name))\n"
"        elif hasattr(cls, svc.name):\n"
"            raise llbc.error('service name is used to Service class attribute, name: {}'.format(svc.name))\n"
"\n"
"        cls._svcs_list.append(svc)\n"
"        cls._svcs_dict[svc.name] = svc\n"
"\n"
"    @classmethod\n"
"    def _removesvc(cls, svc):\n"
"        if svc in cls._svcs_list:\n"
"            cls._svcs_list.remove(svc)\n"
"            del cls._svcs_dict[svc.name]\n"
"\n"
"    @classmethod\n"
"    def _procwilldelsvcs(cls):\n"
"        for svc in cls._will_dels:\n"
"            if svc.started:\n"
"                svc.stop()\n"
"            if svc._terminating:\n"
"                svc._terminating = False\n"
"                svc._terminated = True\n"
"            cls._removesvc(svc)\n"
"\n"
"        cls._will_dels.clear()\n"
"\n"
"    @classmethod\n"
"    def _procpendingdeschedule(cls):\n"
"        if cls._descheduling:\n"
"            cls._descheduling = False\n"
"            return True\n"
"        else:\n"
"            return False\n"
"\n"
"llbc.Service = pyllbcService\n"
"\n"
)));
        _scripts.insert(::std::make_pair("ServiceEvent.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcServiceEvent(object):\n"
"    \"\"\"\n"
"    The llbc service event encapsulation.\n"
"    \"\"\"\n"
"    def __init__(self, svc):\n"
"        self._svc = svc\n"
"        self._idletime = None\n"
"        self._session_id = None\n"
"        self._accept_session_id = None\n"
"        self._connected = None\n"
"        self._reason = None\n"
"        self._local_ip = None\n"
"        self._local_port = None\n"
"        self._peer_ip = None\n"
"        self._peer_port = None\n"
"        self._islisten = None\n"
"        self._socket = None\n"
"        self._packet = None\n"
"        self._report_layer = None\n"
"        self._report_level = None\n"
"        self._report_msg = None\n"
"        self._opcode = None\n"
"        self._destroyed_from_service = None\n"
"        self._errno = None\n"
"        self._sub_errno = None\n"
"\n"
"    @property\n"
"    def svc(self):\n"
"        \"\"\"\n"
"        Service - service object.\n"
"        \"\"\"\n"
"        return self._svc\n"
"\n"
"    @property\n"
"    def idletime(self):\n"
"        \"\"\"sessionId\n"
"        float - idle time, in seconds.\n"
"        \"\"\"\n"
"        return self._idletime\n"
"\n"
"    @property\n"
"    def session_id(self):\n"
"        \"\"\"\n"
"        int - session Id.\n"
"        \"\"\"\n"
"        return self._session_id\n"
"\n"
"    @property\n"
"    def accept_session_id(self):\n"
"        \"\"\"\n"
"        int - accept session Id.\n"
"        \"\"\"\n"
"        return self._accept_session_id\n"
"\n"
"    @property\n"
"    def connected(self):\n"
"        \"\"\"\n"
"        bool - connected flag.\n"
"        \"\"\"\n"
"        return self._connected\n"
"\n"
"    @property\n"
"    def reason(self):\n"
"        \"\"\"\n"
"        str - reason.\n"
"        \"\"\"\n"
"        return self._reason\n"
"\n"
"    @property\n"
"    def localip(self):\n"
"        \"\"\"\n"
"        str - local ip address.\n"
"        \"\"\"\n"
"        return self._local_ip\n"
"\n"
"    @property\n"
"    def localport(self):\n"
"        \"\"\"\n"
"        int - local port number.\n"
"        \"\"\"\n"
"        return self._local_port\n"
"\n"
"    @property\n"
"    def peerip(self):\n"
"        \"\"\"\n"
"        str - peer ip address.\n"
"        \"\"\"\n"
"        return self._peer_ip\n"
"\n"
"    @property\n"
"    def peerport(self):\n"
"        \"\"\"\n"
"        int - peer port number.\n"
"        \"\"\"\n"
"        return self._peer_port\n"
"\n"
"    @property\n"
"    def islisten(self):\n"
"        \"\"\"\n"
"        bool - listen socket flag.\n"
"        \"\"\"\n"
"        return self._islisten\n"
"\n"
"    @property\n"
"    def socket(self):\n"
"        \"\"\"\n"
"        int - socket file descripter.\n"
"        \"\"\"\n"
"        return self._socket\n"
"\n"
"    @property\n"
"    def packet(self):\n"
"        \"\"\"\n"
"        Packet - packet object.\n"
"        \"\"\"\n"
"        return self._packet\n"
"\n"
"    @property\n"
"    def report_layer(self):\n"
"        \"\"\"\n"
"        int - report layer.\n"
"        \"\"\"\n"
"        return self._report_layer\n"
"\n"
"    @property\n"
"    def report_level(self):\n"
"        \"\"\"\n"
"        int - report level\n"
"        \"\"\"\n"
"        return self._report_level\n"
"\n"
"    @property\n"
"    def report_msg(self):\n"
"        \"\"\"\n"
"        str - report message.\n"
"        \"\"\"\n"
"        return self._report_msg\n"
"\n"
"    @property\n"
"    def opcode(self):\n"
"        \"\"\"\n"
"        int - packet opcode.\n"
"        \"\"\"\n"
"        return self._opcode\n"
"\n"
"    @property\n"
"    def destroyed_from_service(self):\n"
"        \"\"\"\n"
"        bool - destroyed from service flag.\n"
"        \"\"\"\n"
"        return self._destroyed_from_service\n"
"\n"
"    @property\n"
"    def errno(self):\n"
"        \"\"\"\n"
"        int - error number, 0 if success.\n"
"        \"\"\"\n"
"        return self._errno\n"
"\n"
"    @property\n"
"    def sub_errno(self):\n"
"        \"\"\"\n"
"        int - sub error number, 0 if success.\n"
"        \"\"\"\n"
"        return self._sub_errno\n"
"\n"
"    def __str__(self):\n"
"        s = 'svc: {}'.format(self._svc)\n"
"        if self._idletime is not None:\n"
"            s += ', idletime: {}'.format(self._idletime)\n"
"        if self._session_id is not None:\n"
"            s += ', session_id: {}'.format(self._session_id)\n"
"        if self._connected is not None:\n"
"            s += ', connected: {}'.format(self._connected)\n"
"        if self._reason is not None:\n"
"            s += ', reason: {}'.format(self._reason)\n"
"        if self._local_ip is not None:\n"
"            s += ', localaddr: {}:{}'.format(self._local_ip, self._local_port)\n"
"        if self._peer_ip is not None:\n"
"            s += ', peeraddr: {}:{}'.format(self._peer_ip, self._peer_port)\n"
"        if self._islisten is not None:\n"
"            s += ', islisten: {}'.format(self._islisten)\n"
"        if self._socket is not None:\n"
"            s += ', socket: {}'.format(self._socket)\n"
"        if self._packet is not None:\n"
"            s += ', packet: [{}]'.format(self._packet)\n"
"        if self._report_layer is not None:\n"
"            s += ', report_layer: {}'.format(llbc.Protocol.layer2str(self._report_layer))\n"
"        if self._report_level is not None:\n"
"            s += ', report_level: {}'.format(llbc.Protocol.level2str(self._report_level))\n"
"        if self._report_msg is not None:\n"
"            s += ', report_msg: {}'.format(self._report_msg)\n"
"        if self._opcode is not None:\n"
"            s += ', opcode: {}'.format(self._opcode)\n"
"        if self._destroyed_from_service is not None:\n"
"            s += ', from_service?: {}'.format(self._destroyed_from_service)\n"
"        if self._errno is not None:\n"
"            s += ', errno: {}'.format(self._errno)\n"
"        if self._sub_errno is not None:\n"
"            s += ', sub_errno: {}'.format(self._sub_errno)\n"
"\n"
"        return s\n"
"\n"
"llbc.ServiceEvent = pyllbcServiceEvent\n"
"\n"
)));
        _scripts.insert(::std::make_pair("Timer.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import time as _time\n"
"\n"
"from datetime import datetime as _dt\n"
"from datetime import tzinfo as _tzinfo\n"
"from datetime import timedelta as _timedelta\n"
"\n"
"import llbc\n"
"\n"
"class _pyllbcGMT(_tzinfo):\n"
"    \"\"\"llbc library GMT tzinfo class encapsulation\"\"\"\n"
"    _delta = _timedelta(0)\n"
"    def utcoffset(self, dt):\n"
"        return self._delta\n"
"\n"
"    def tzname(self):\n"
"        return \"GMT+0\"\n"
"\n"
"    def dst(self, dt):\n"
"        return None\n"
"\n"
"class _pyllbcLOCAL(_tzinfo):\n"
"    \"\"\"llbc library LOCAL tzinfo class encapsulation\"\"\"\n"
"    _delta = _timedelta(seconds=-_time.timezone)\n"
"    _tzname = 'GMT +{}'.format(-_time.timezone / 3600) if _time.timezone < 0 else \\\n"
"            ('GMT -{}'.format(_time.timezone / 3600) if _time.timezone > 0 else 'GMT +0')\n"
"\n"
"    def utcoffset(self, dt):\n"
"        return self._delta\n"
"\n"
"    def tzname(self):\n"
"        return self._tzname\n"
"\n"
"    def dst(self, dt):\n"
"        return None\n"
"\n"
"class pyllbcTimer(object):\n"
"    \"\"\"llbc library timer class encapsulation\"\"\"\n"
"    INVALID_TIMER_ID = 0\n"
"\n"
"    \"\"\"llbc library timer class encapsulation\"\"\"\n"
"    def __init__(self, ontimeout, oncancel=None):\n"
"        if not callable(ontimeout):\n"
"            raise TypeError(\"'ontimeout' obj must callable\")\n"
"\n"
"        if not callable(oncancel):\n"
"            self.__c_obj = llbc.inl.NewPyTimer(self, ontimeout)\n"
"        else:\n"
"            self.__c_obj = llbc.inl.NewPyTimer(self, ontimeout, oncancel)\n"
"\n"
"    def __del__(self):\n"
"        llbc.inl.DelPyTimer(self.__c_obj)\n"
"\n"
"    @property\n"
"    def timerid(self):\n"
"        return llbc.inl.PyTimerGetTimerId(self.__c_obj)\n"
"\n"
"    @property\n"
"    def duetime(self):\n"
"        return llbc.inl.PyTimerGetDueTime(self.__c_obj)\n"
"\n"
"    @property\n"
"    def period(self):\n"
"        return llbc.inl.PyTimerGetPeriod(self.__c_obj)\n"
"\n"
"    @property\n"
"    def isscheduling(self):\n"
"        return llbc.inl.PyTimerIsScheduling(self.__c_obj)\n"
"\n"
"    @property\n"
"    def istimeouting(self):\n"
"        return llbc.inl.PyTimerIsTimeouting(self.__c_obj)\n"
"\n"
"    @property\n"
"    def iscancelling(self):\n"
"        return llbc.inl.PyTimerIsCancelling(self.__c_obj)\n"
"\n"
"    @property\n"
"    def ignored_dead_ref(self):\n"
"        return llbc.inl.PyTimerIsIgnoredDeadRef(self.__c_obj)\n"
"\n"
"    @ignored_dead_ref.setter\n"
"    def ignored_dead_ref(self, flag):\n"
"        llbc.inl.PyTimerSetIgnoredDeadRef(self.__c_obj, flag)\n"
"\n"
"    def schedule(self, duetime, period=None):\n"
"        \"\"\"Schedule timer\"\"\"\n"
"        if period is None:\n"
"            period = duetime\n"
"\n"
"        llbc.inl.PyTimerSchedule(self.__c_obj, duetime, period)\n"
"\n"
"    def schedule2(self, duetime, period, fmtstr='%Y-%m-%d %H:%M:%S'):\n"
"        \"\"\"\n"
"        Schedule timer, arguments is datetime type object, str type object, or numeric type object,\n"
"            if duetime type is datetime type object, will use it as expire time.\n"
"            if duetime type is str type, will convert to datetime type to use.\n"
"            if duetime type is numeric type, will as timestamp to use, as seconds.\n"
"        If not specified the tzinfo, llbc will automatic use local tzinfo to fill.\n"
"        \"\"\"\n"
"        if isinstance(duetime, unicode):\n"
"            duetime = duetime.decode('utf-8')\n"
"        if isinstance(duetime, str):\n"
"            duetime = _dt.strptime(duetime, fmtstr)\n"
"\n"
"        if isinstance(duetime, _dt):\n"
"            ts = _time.mktime(duetime.timetuple()) + duetime.microsecond / 1000000.0\n"
"        else:\n"
"            ts = duetime\n"
"\n"
"        now = _time.time()\n"
"        if ts < now:\n"
"            raise llbc.error('duetime[{}] < nowtime[{}], schedule timer failed'.format(duetime, _dt.fromtimestamp(now)))\n"
"\n"
"        self.schedule(int((ts - now) * 1000), int(period * 1000))\n"
"\n"
"    def cancel(self):\n"
"        \"\"\"Cancel timer\"\"\"\n"
"        llbc.inl.PyTimerCancel(self.__c_obj)\n"
"\n"
"llbc.Timer = pyllbcTimer\n"
)));
        _scripts.insert(::std::make_pair("Enum.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"def pyllbcEnum(*sequential, **named):\n"
"    \"\"\"\n"
"    The enum helper function.\n"
"    \"\"\"\n"
"    enums = dict(zip(sequential, range(len(sequential))), **named)\n"
"    return type('Enum', (), enums)\n"
"\n"
"llbc.Enum = pyllbcEnum\n"
"\n"
)));
        _scripts.insert(::std::make_pair("Stream.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import inspect\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcStream(object):\n"
"    \"\"\"\n"
"    Stream class encapsulation, use to pack/unpack data sequence.\n"
"    \"\"\"\n"
"    def __init__(self, size=0, init_obj=None, endian=llbc.Endian.MachineEndian):\n"
"        self.__c_obj = llbc.inl.NewPyStream(self, size, endian)\n"
"        self.packobj(init_obj)\n"
"\n"
"    def __del__(self):\n"
"        llbc.inl.DelPyStream(self.__c_obj)\n"
"\n"
"    @property\n"
"    def endian(self):\n"
"        \"\"\"\n"
"        Get stream endian setting(see llbc.Endian module).\n"
"        \"\"\"\n"
"        return llbc.inl.GetPyStreamEndian(self.__c_obj)\n"
"\n"
"    @endian.setter\n"
"    def endian(self, e):\n"
"        \"\"\"\n"
"        Set stream endian(see llbc.Endian module).\n"
"        \"\"\"\n"
"        llbc.inl.SetPyStreamEndian(self.__c_obj, e)\n"
"\n"
"    @property\n"
"    def pos(self):\n"
"        \"\"\"\n"
"        Get stream current reading/writing position.\n"
"        \"\"\"\n"
"        return llbc.inl.GetPyStreamPos(self.__c_obj)\n"
"\n"
"    @pos.setter\n"
"    def pos(self, p):\n"
"        \"\"\"\n"
"        Set stream current reading/writing position.\n"
"        \"\"\"\n"
"        llbc.inl.SetPyStreamPos(self.__c_obj, p)\n"
"\n"
"    @property\n"
"    def size(self):\n"
"        \"\"\"\n"
"        Get stream size(unsafe method, size will automatic adjust by stream).\n"
"        \"\"\"\n"
"        return llbc.inl.GetPyStreamSize(self.__c_obj)\n"
"\n"
"    @size.setter\n"
"    def size(self, s):\n"
"        \"\"\"\n"
"        Set stream size(unsafe method, size will automatic adjust by stream).\n"
"        \"\"\"\n"
"        llbc.inl.SetPyStreamSize(self.__c_obj, s)\n"
"\n"
"    @property\n"
"    def raw(self):\n"
"        \"\"\"\n"
"        Get stream memery view as buffer.\n"
"        \"\"\"\n"
"        return llbc.inl.PyStreamGetRaw(self.__c_obj)\n"
"\n"
"    @raw.setter\n"
"    def raw(self, r):\n"
"        \"\"\"\n"
"        Set stream raw memory from str/buffer/bytearray.\n"
"        \"\"\"\n"
"        llbc.inl.PyStreamSetRaw(self.__c_obj, r)\n"
"\n"
"    @property\n"
"    def cobj(self):\n"
"        \"\"\"\n"
"        Get raw pyllbc stream object(calling by c/c++ layer).\n"
"        \"\"\"\n"
"        return self.__c_obj\n"
"\n"
"    def __str__(self):\n"
"        \"\"\"\n"
"        Get human readable stream data's string representation.\n"
"        \"\"\"\n"
"        import binascii\n"
"        return binascii.hexlify(self.raw)\n"
"\n"
"    @staticmethod\n"
"    def getcachedsize():\n"
"        return llbc.inl.PyStreamGetCachedSize()\n"
"\n"
"    @staticmethod\n"
"    def getcachelimit():\n"
"        return llbc.inl.PyStreamGetCacheLimit()\n"
"\n"
"    @staticmethod\n"
"    def setcachelimit(lmt):\n"
"        llbc.inl.PyStreamSetCacheLimit(lmt)\n"
"\n"
"    @staticmethod\n"
"    def discardexpr(expr):\n"
"        llbc.inl.PyStreamDiscardExpr(expr)\n"
"\n"
"    @staticmethod\n"
"    def discardallexprs():\n"
"        llbc.inl.PyStreamDiscardAllExprs()\n"
"\n"
"    def unpack(self, fmt):\n"
"        \"\"\"\n"
"        Unpack data according to the given format. the result is a tuple even if it contents exactly one item.\n"
"        format strings:\n"
"           c: char value(like b).\n"
"           b: byte value(like c).\n"
"\n"
"           B: boolean value.\n"
"           s: short value.\n"
"           i: integer value.\n"
"           q: signed long long value.\n"
"           f: float value.\n"
"           d: double value(only support Fomat method).\n"
"\n"
"           S: string value.\n"
"           S#: string value, use another pack/unpack algorithm, 4 bytes length + string content(not include NULL character).\n"
"           U: unicode value.\n"
"\n"
"           A: byte array value.\n"
"           F: buffer value.\n"
"\n"
"           N: None value.\n"
"\n"
"           C: class type, will automatic call class.encode() method to decode must tell stream this class name, \n"
"              use C<ClassName> semantic.\n"
"           (): tuple type, if only has one element,  it represent tuple all element type is the given type, otherwise\n"
"               the tuple size must equal your given element count.\n"
"           []: list type, the same as tuple type: ().\n"
"           {key:value}: dictionary type.\n"
"           \n"
"        The format examples:\n"
"               iiS\n"
"               (i)\n"
"               (U)\n"
"               [i]\n"
"               {i:S}\n"
"               {i:(C<int>)}\n"
"               ([SC<int>NA(i)]{int:S}B\n"
"        \"\"\"\n"
"        return self.__unpack(fmt)\n"
"\n"
"    def unpackone(self, fmt):\n"
"        return self.__unpack(fmt)[0]\n"
"\n"
"    def unpackcls(self, cls):\n"
"        return llbc.inl.PyStreamRead(self.__c_obj, cls)\n"
"\n"
"    def unpacknone(self):\n"
"        return llbc.inl.PyStreamRead_None(self.__c_obj)\n"
"\n"
"    def unpackbyte(self):\n"
"        return llbc.inl.PyStreamRead_Byte(self.__c_obj)\n"
"\n"
"    def unpackbool(self):\n"
"        return llbc.inl.PyStreamRead_Bool(self.__c_obj)\n"
"\n"
"    def unpackint16(self):\n"
"        return llbc.inl.PyStreamRead_Int16(self.__c_obj)\n"
"\n"
"    def unpackint32(self):\n"
"        return llbc.inl.PyStreamRead_Int32(self.__c_obj)\n"
"\n"
"    def unpackint64(self):\n"
"        return llbc.inl.PyStreamRead_Int64(self.__c_obj)\n"
"\n"
"    def unpackfloat(self):\n"
"        return llbc.inl.PyStreamRead_Float(self.__c_obj)\n"
"\n"
"    def unpackdouble(self):\n"
"        return llbc.inl.PyStreamRead_Double(self.__c_obj)\n"
"\n"
"    def unpackstr(self):\n"
"        return llbc.inl.PyStreamRead_Str(self.__c_obj)\n"
"\n"
"    def unpackstr2(self):\n"
"        return llbc.inl.PyStreamRead_Str2(self.__c_obj)\n"
"\n"
"    def unpackunicode(self):\n"
"        return llbc.inl.PyStreamRead_Unicode(self.__c_obj)\n"
"\n"
"    def unpackbytearray(self):\n"
"        return llbc.inl.PyStreamRead_ByteArray(self.__c_obj)\n"
"\n"
"    def unpackbuffer(self):\n"
"        return llbc.inl.PyStreamRead_Buffer(self.__c_obj)\n"
"\n"
"    def unpackstream(self, begin=0, end=-1):\n"
"        return llbc.inl.PyStreamRead_Stream(self.__c_obj, begin, end)\n"
"\n"
"    def pack(self, fmt, *values):\n"
"        \"\"\"\n"
"        Pack values according to the given format, the arguments must match the values required by the format exactly.\n"
"        format strings:\n"
"           c: char value(like b).\n"
"           b: byte value(like c).\n"
"\n"
"           B: boolean value.\n"
"           s: short value.\n"
"           i: integer value.\n"
"           q: signed long long value.\n"
"           f: float value.\n"
"           d: double value(only support Fomat method).\n"
"\n"
"           S: string value.\n"
"           S#: string value, use another pack/unpack algorithm, 4 bytes length + string content(not include NULL character).\n"
"           U: unicode value.\n"
"\n"
"           A: byte array value.\n"
"           F: buffer value.\n"
"\n"
"           N: None value.\n"
"\n"
"           C: class type, will automatic call class.encode() method to decode, must tell stream this class name, \n"
"              use C<ClassName> semantic.\n"
"           (): tuple type, if only has one element,  it represent tuple all element type is the given type, otherwise\n"
"               the tuple size must equal your given element count.\n"
"           []: list type, the same as tuple type: ().\n"
"           {key:value}: dictionary type.\n"
"        \"\"\"\n"
"\n"
"        caller_env = None\n"
"        if fmt.find('C') >= 0 and not llbc.inl.PyStreamIsExprCompiled(fmt):\n"
"            caller_env = inspect.stack()[1][0].f_globals\n"
"\n"
"        return llbc.inl.PyStreamFmtWrite(self.__c_obj, fmt, values, caller_env)\n"
"\n"
"    def packobj(self, obj):\n"
"        return llbc.inl.PyStreamWrite(self.__c_obj, obj)\n"
"\n"
"    def packnone(self):\n"
"        return llbc.inl.PyStreamWrite_None(self.__c_obj, None)\n"
"\n"
"    def packbyte(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Byte(self.__c_obj, obj)\n"
"\n"
"    def packbool(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Bool(self.__c_obj, obj)\n"
"\n"
"    def packint16(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Int16(self.__c_obj, obj)\n"
"\n"
"    def packint32(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Int32(self.__c_obj, obj)\n"
"\n"
"    def packint64(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Int64(self.__c_obj, obj)\n"
"\n"
"    def packfloat(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Float(self.__c_obj, obj)\n"
"\n"
"    def packdouble(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Double(self.__c_obj, obj)\n"
"\n"
"    def packstr(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Str(self.__c_obj, obj)\n"
"\n"
"    def packstr2(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Str2(self.__c_obj, obj)\n"
"\n"
"    def packunicode(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Unicode(self.__c_obj, obj)\n"
"\n"
"    def packbytearray(self, obj):\n"
"        return llbc.inl.PyStreamWrite_ByteArray(self.__c_obj, obj)\n"
"\n"
"    def packbuffer(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Buffer(self.__c_obj, obj)\n"
"\n"
"    def packtuple(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Tuple(self.__c_obj, obj)\n"
"\n"
"    def packlist(self, obj):\n"
"        return llbc.inl.PyStreamWrite_List(self.__c_obj, obj)\n"
"\n"
"    def packsequence(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Sequence(self.__c_obj, obj)\n"
"\n"
"    def packdict(self, obj):\n"
"        return llbc.inl.PyStreamWrite_Dict(self.__c_obj, obj)\n"
"\n"
"    def packstream(self, s, begin=0, to=-1):\n"
"        if not isinstance(s, pyllbcStream):\n"
"            raise TypeError('pack argument \"s\" must be stream type')\n"
"        return llbc.inl.PyStreamWrite_Stream(self.__c_obj, s.cobj, begin, to)\n"
"\n"
"    def encode(self, s):\n"
"        if not isinstance(s, pyllbcStream):\n"
"            raise TypeError('encode argument not Stream type')\n"
"\n"
"        return llbc.inl.PyStreamEncodeSelf(self.__c_obj, s.cobj)\n"
"\n"
"    def __unpack(self, fmt, stack_idx=1):\n"
"        caller_env = None\n"
"        if fmt.find('C') >= 0 and not llbc.inl.PyStreamIsExprCompiled(fmt):\n"
"            caller_env = inspect.stack()[stack_idx + 1][0].f_globals\n"
"\n"
"        return llbc.inl.PyStreamFmtRead(self.__c_obj, fmt, caller_env)\n"
"\n"
"llbc.Stream = pyllbcStream\n"
"\n"
)));
        _scripts.insert(::std::make_pair("Bundle.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"from os import path as op\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcBundle(object):\n"
"    \"\"\"The Bundle about operations encapsulation\"\"\"\n"
"    def __init__(self, path, main=False):\n"
"        self.__main = main\n"
"        if self.__main:\n"
"            self.__c_obj = llbc.inl.GetMainBundle()\n"
"        else:\n"
"            self.__c_obj = llbc.inl.NewBundle()\n"
"            llbc.inl.InitBundle(self.__c_obj, path)\n"
"\n"
"    def __del__(self):\n"
"        if not self.__main:\n"
"            llbc.inl.DelBundle(self.__c_obj)\n"
"\n"
"    @staticmethod\n"
"    def mainbundle():\n"
"        return pyllbcBundle(path=\"\", main=True)\n"
"\n"
"    @property\n"
"    def path(self):\n"
"        return llbc.inl.GetBundlePath(self.__c_obj)\n"
"\n"
"    @property\n"
"    def name(self):\n"
"        return llbc.inl.GetBundleName(self.__c_obj)\n"
"\n"
"    def getrespath(self, resname, ext=\"\", intdir=\"\"):\n"
"        return llbc.inl.GetBundleResPath(self.__c_obj, resname, ext, intdir)\n"
"        \n"
"llbc.Bundle = pyllbcBundle\n"
"\n"
)));
        _scripts.insert(::std::make_pair("Property.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcProperty(object):\n"
"    \"\"\"\n"
"    pyllbc property class encapsulation.\n"
"    property can read & write .cfg format file.\n"
"    file format:\n"
"        path.to.name = value # The comments\n"
"        path.to.anotherName = \\#\\#\\# anotherValue \\#\\#\\#  # The comments too\n"
"    Property class can parse or serialize this format's file.\n"
"    \"\"\"\n"
"    def __init__(self, prop_file=''):\n"
"        self._c_obj = llbc.inl.Property_New(prop_file)\n"
"\n"
"    def __del__(self):\n"
"        llbc.inl.Property_Delete(self._c_obj)\n"
"\n"
"    def from_content(self, content):\n"
"        \"\"\"\n"
"        Load properties from string content.\n"
"        :param content: the string content.\n"
"        \"\"\"\n"
"        llbc.inl.Property_FromContent(self._c_obj, content)\n"
"\n"
"    def from_file(self, prop_file):\n"
"        \"\"\"\n"
"        Load properties from specifics property file.\n"
"        :param prop_file: the property file path.\n"
"        \"\"\"\n"
"        llbc.inl.Property_FromFile(self._c_obj, prop_file)\n"
"\n"
"    def to_content(self):\n"
"        \"\"\"\n"
"        Serialize the properties as string.\n"
"        :return: the serialized properties' string representation.\n"
"        \"\"\"\n"
"        return llbc.inl.Property_ToContent(self._c_obj)\n"
"\n"
"    def to_file(self, prop_file):\n"
"        \"\"\"\n"
"        Serialize the properties to file.\n"
"        :param prop_file: the property file path.\n"
"        \"\"\"\n"
"        llbc.inl.Property_ToFile(self._c_obj, prop_file)\n"
"\n"
"    def getvalue(self, name='', default=None, as_type=str):\n"
"        \"\"\"\n"
"        Get property value by property name.\n"
"        examples:\n"
"            db_host = prop.getvalue(\"Server.DB.Host\", \"127.0.0.1\")\n"
"            db_port = prop.getvalue(\"Server.DB.Port\", default=3306, as_type=int)\n"
"\n"
"            client_host = prop.get_property(\"Server.Client.Host\").getvalue();\n"
"            client_port = prop.get_property(\"Server.Client.Port\").getvalue(as_type=int);\n"
"\n"
"            Note:\n"
"                If caller not pass the 'name' parameter or pass name parameter as '', will return\n"
"                self property's value, if this property is leaf-property will return real value,\n"
"                otherwise will return default value.\n"
"                If name format error, will raise llbc.error exception.\n"
"        :param name: the property, if pass a error format name, will raise llbc.error exception.\n"
"        :param default: default error when could not found specific name's property value, will\n"
"                        return this default. specially, if the default is None, the return value\n"
"                        is \"as_type' is means return as_type().\n"
"        :param as_type: as type, Property class using str type to store all property values, if\n"
"                        not specific your type, will always return str type value.\n"
"        :return: the property value.\n"
"        \"\"\"\n"
"        val = llbc.inl.Property_GetValue(self._c_obj, name)\n"
"        if val is None:\n"
"            return as_type() if default is None else default\n"
"        else:\n"
"            return as_type(val)\n"
"        \n"
"    def setvalue(self, name, value, comments=\"\"):\n"
"        \"\"\"\n"
"        Set property value.\n"
"        :param name: the property name.\n"
"        :param value: the property value, will convert str type to store.\n"
"        :param comments: the comments, default is empty.\n"
"        \"\"\"\n"
"        llbc.inl.Property_SetValue(self._c_obj, name, value, comments)\n"
"\n"
"    def get_comments(self, name=''):\n"
"        \"\"\"\n"
"        Get specific property's comments, if name is '', return self property's comments.\n"
"        :param name: property name.\n"
"        :return: the property comments.\n"
"        \"\"\"\n"
"        return llbc.inl.Property_GetComments(self._c_obj, name)\n"
"\n"
"    def set_comments(self, name, comments):\n"
"        \"\"\"\n"
"        Set specific property's comments, if name is '', return self property's comments.\n"
"        :param name: property name.\n"
"        :param comments: property comments.\n"
"        :return: None.\n"
"        \"\"\"\n"
"        llbc.inl.Property_SetComments(self._c_obj, name, comments)\n"
"\n"
"    def get_property(self, name):\n"
"        \"\"\"\n"
"        Get the property.\n"
"        \"\"\"\n"
"        return llbc.inl.Property_GetProperty(self._c_obj, name)\n"
"\n"
"    def get_property_count(self):\n"
"        \"\"\"\n"
"        Get property count.\n"
"        :return: the property count.\n"
"        \"\"\"\n"
"        return llbc.inl.Property_GetPropertyCount(self._c_obj)\n"
"\n"
"    def get_property_names(self, nest=False):\n"
"        \"\"\"\n"
"        Get property names.\n"
"        :param nest: get all left-properties names or not, default is False.\n"
"        :return: the property names.\n"
"        \"\"\"\n"
"        return llbc.inl.Property_GetPropertyNames(self._c_obj, nest)\n"
"\n"
"    def has_property(self, name):\n"
"        \"\"\"\n"
"        Check this property has specific name's property or not.\n"
"        :param name: the property name.\n"
"        :return: return True if has specific name's property, otherwise return False.\n"
"        \"\"\"\n"
"        return llbc.inl.Property_HasProperty(self._c_obj, name)\n"
"\n"
"    def remove_property(self, name, remove_all=True):\n"
"        \"\"\"\n"
"        Remoev specific name's property.\n"
"        :param name: the property name.\n"
"        :param remove_all: remove all flag.\n"
"        \"\"\"\n"
"        llbc.inl.Property_RemoveProperty(self._c_obj, name, remove_all)\n"
"\n"
"    def remove_all_properties(self):\n"
"        \"\"\"\n"
"        Remove all properties.\n"
"        \"\"\"\n"
"        llbc.inl.Property_RemoveAllProperties(self._c_obj)\n"
"\n"
"    def __getattr__(self, key):\n"
"        return llbc.inl.Property_GetProperty(self._c_obj, key)\n"
"\n"
"    def __int__(self):\n"
"        return self.getvalue('', as_type=int)\n"
"\n"
"    def __long__(self):\n"
"        return self.getvalue('', as_type=long)\n"
"\n"
"    def __float__(self):\n"
"        return self.getvalue('', as_type=float)\n"
"\n"
"    def __str__(self):\n"
"        return self.getvalue('', as_type=str)\n"
"\n"
"    def __nonzero__(self):\n"
"        val = self.getvalue('', as_type=str)\n"
"        val_len = len(val)\n"
"        if val_len == 0:\n"
"            return False\n"
"        elif val_len == 4 and val.lower() == 'true':\n"
"            return True\n"
"\n"
"        try:\n"
"            float_val = float(val)\n"
"        except Exception, e:\n"
"            return False\n"
"        else:\n"
"            return float_val != 0.0\n"
"\n"
"    def __kvdict(self):\n"
"        return dict([(key, self.get_property(key)) for key in self.get_property_names(nest=True)])\n"
"\n"
"    def iterkeys(self):\n"
"        return self.__kvdict().iterkeys()\n"
"\n"
"    def itervalues(self):\n"
"        return self.__kvdict().itervalues()\n"
"\n"
"    def iteritems(self):\n"
"        return self.__kvdict().iteritems()\n"
"\n"
"    def __iter__(self):\n"
"        return self.__kvdict().__iter__()\n"
"\n"
"llbc.Property = pyllbcProperty\n"
"\n"
)));
        _scripts.insert(::std::make_pair("ParamVerify.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import inspect\n"
"from re import match\n"
"from functools import wraps\n"
"from types import ClassType, TypeType\n"
"\n"
"from llbc import error as error\n"
"\n"
"def pyllbc_varify_param(*varargs, **kwargs):\n"
"    \"\"\"\n"
"    Parameters varify decorator.\n"
"    \"\"\"\n"
"    varargs = map(_to_standard_condition, varargs)\n"
"    kwargs = dict((k, _to_standard_condition(kwargs[k])) for k in kwargs)\n"
"\n"
"    def generator(func):\n"
"        arg_names, vararg_name, kw_name = inspect.getargspec(func)[:3]\n"
"        validator = _get_call_args(arg_names, vararg_name, kw_name, varargs, kwargs)\n"
"\n"
"        @wraps(func)\n"
"        def wrapper(*call_varargs, **call_kwargs):\n"
"            call_args = _get_call_args(arg_names, vararg_name, kw_name, call_varargs, call_kwargs)\n"
"            k, item = None, None\n"
"            try:\n"
"                for k in validator:\n"
"                    if k == vararg_name:\n"
"                        for item in call_args[k]:\n"
"                            assert validator[k](item)\n"
"                    elif k == kw_name:\n"
"                        for item in call_args[k].itervalues():\n"
"                            assert validator[k](item)\n"
"                    else:\n"
"                        item = call_args[k]\n"
"                        assert validator[k](item)\n"
"            except:\n"
"                raise error('{}() parameter validation failed, param: {}, value: {}({})'\n"
"                        .format(func.func_name, k, item, item.__class__.__name__))\n"
"\n"
"            return func(*call_varargs, **call_kwargs)\n"
"        return wrapper\n"
"    return generator\n"
"\n"
"def pyllbc_null_ok(cls, cond=None):\n"
"    \"\"\"\n"
"    Decorator to let condition can accept None value.\n"
"    \"\"\"\n"
"    return lambda x: x is None or _to_standard_condition((cls, cond))(x)\n"
"\n"
"def pyllbc_multi_type(*conds):\n"
"    \"\"\"\n"
"    Decorator to specific multi conditions/types, as long as one cond/class check pass, if return True.\n"
"    \"\"\"\n"
"    validators = map(_to_standard_condition, conds)\n"
"    def validate(x):\n"
"        for v in validators:\n"
"            if v(x):\n"
"                return True\n"
"            return False\n"
"\n"
"    return validate\n"
"\n"
"llbc.varify_param = pyllbc_varify_param\n"
"llbc.null_ok = pyllbc_null_ok\n"
"llbc.multi_type = pyllbc_multi_type\n"
"\n"
"def _to_standard_condition(cond):\n"
"    \"\"\"\n"
"    Decorator to convert all check conditions/classes to check functions.\n"
"    \"\"\"\n"
"    if type(cond) in (ClassType, TypeType):\n"
"        return lambda x: isinstance(x, cond)\n"
"    elif isinstance(cond, (tuple, list)):\n"
"        cls, cond = cond[:2]\n"
"        if cond is None:\n"
"            return _to_standard_condition(cls)\n"
"        elif cls in (str, unicode) and cond[0] == cond[-1] == '/':\n"
"            return lambda x: (isinstance(x, cls) and match(cond[1:-1], x) is not None)\n"
"\n"
"        return lambda x: isinstance(x, cls) and eval(cond)\n"
"    return cond\n"
"\n"
"def _get_call_args(arg_names, vararg_name, kw_name, varargs, kwargs):\n"
"    \"\"\"\n"
"    Decorator to integrate parameter names and values.\n"
"    \"\"\"\n"
"    call_dict = {}\n"
"    varargs = tuple(varargs)\n"
"    kwargs = dict(kwargs)\n"
"\n"
"    call_varargs = None\n"
"    var_arg_cnt = len(varargs)\n"
"    arg_names_cnt = len(arg_names)\n"
"\n"
"    if arg_names_cnt <= var_arg_cnt:\n"
"        for n, arg_name in enumerate(arg_names):\n"
"            call_dict[arg_name] = varargs[n]\n"
"\n"
"        call_carargs = varargs[-(var_arg_cnt - arg_names_cnt):]\n"
"    else:\n"
"        for n, var in enumerate(varargs):\n"
"            call_dict[arg_names[n]] = var\n"
"\n"
"        for arg_name in arg_names[-(arg_names_cnt - var_arg_cnt):]:\n"
"            if arg_name in kwargs:\n"
"                call_dict[arg_name] = kwargs.pop(arg_name)\n"
"\n"
"        call_varargs = ()\n"
"\n"
"\n"
"    if vararg_name is not None:\n"
"        call_dict[vararg_name] = call_varargs\n"
"\n"
"    if kw_name is not None:\n"
"        call_dict[kw_name] = kwargs\n"
"\n"
"    call_dict.update(kwargs)\n"
"\n"
"    return call_dict\n"
"\n"
)));
        _scripts.insert(::std::make_pair("Observable.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"from weakref import ref\n"
"from types import MethodType\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcObservable(object):\n"
"    \"\"\"\n"
"    llbc library Observable class encapsulation.\n"
"    \"\"\"\n"
"    # Observer type enumeration.\n"
"    # Callable: Callable observer(not include MethodType and obj.update() specific method.\n"
"    # Method: MethodType observer(must establish special weakref object to hold the observer.\n"
"    ObserverType = pyllbcEnum('Callable', 'Method')\n"
"\n"
"    # Lazy operation type enumeration.\n"
"    LazyOpType = pyllbcEnum('Add', 'Remove', 'RemoveAll', 'Notify', 'Invalid')\n"
"\n"
"    class WrappedObserver(object):\n"
"        \"\"\"\n"
"        Wrapped observer class encapsulation.\n"
"        \"\"\"\n"
"        def __init__(self, ob):\n"
"            ob_type = pyllbcObservable.ObserverType\n"
"            if callable(ob):\n"
"                if type(ob) == MethodType:\n"
"                    if not ob.__self__:\n"
"                        raise llbc.error('observer is MethodType, but method unbound')\n"
"                    self.type = ob_type.Method\n"
"                    self.ref = ref(ob.__self__)\n"
"                    self.func = ob.im_func\n"
"                else:\n"
"                    self.type = ob_type.Callable\n"
"                    self.ref = ref(ob)\n"
"            else:\n"
"                raise llbc.error('observer not callable, observer: {}'.format(ob))\n"
"            \n"
"        def __call__(self, observable, *args, **kwargs):\n"
"            \"\"\"\n"
"            Callable method impl.\n"
"            \"\"\"\n"
"            ref_obj = self.ref()\n"
"            if ref_obj is None:\n"
"                return False\n"
"\n"
"            ob_type = pyllbcObservable.ObserverType\n"
"            if self.type == ob_type.Method:\n"
"                self.func(ref_obj, observable, *args, **kwargs)\n"
"            else:\n"
"                ref_obj(observable, *args, **kwargs)\n"
"\n"
"            return True\n"
"\n"
"        def __nonzero__(self):\n"
"            \"\"\"\n"
"            Makesure this observer is alive.\n"
"            \"\"\"\n"
"            return True if self.ref() is not None else False\n"
"\n"
"        def is_this(self, other):\n"
"            WrappedOb = pyllbcObservable.WrappedObserver\n"
"            if not isinstance(other, WrappedOb):\n"
"                other = WrappedOb(other)\n"
"\n"
"            other_ref = other.ref()\n"
"            if other_ref is None:\n"
"                return False\n"
"\n"
"            self_ref = self.ref()\n"
"            if self_ref is None:\n"
"                return False\n"
"\n"
"            if other.type != self.type:\n"
"                return False\n"
"            elif self_ref is not other_ref:\n"
"                return False\n"
"\n"
"            ob_type = pyllbcObservable.ObserverType\n"
"            if self.type == ob_type.Method:\n"
"                return self.func is other.func\n"
"            else:\n"
"                return True\n"
"\n"
"    class LazyOp(object):\n"
"        def __init__(self):\n"
"            self.op_type = pyllbcObservable.LazyOpType.Invalid\n"
"            self.observer = None\n"
"            self.ntf_data = None\n"
"\n"
"    def __init__(self):\n"
"        self.__notifying = 0\n"
"        self.__observers = []\n"
"        self.__lazy_ops = []\n"
"\n"
"    def __contains__(self, other):\n"
"        WrappedOb = pyllbcObservable.WrappedObserver\n"
"        if not isinstance(other, WrappedOb):\n"
"            other = WrappedOb(other)\n"
"\n"
"        for saved_wrapped_ob in self.__observers:\n"
"            if saved_wrapped_ob.is_this(other):\n"
"                return True\n"
"\n"
"        add_times = 0\n"
"        op_type = pyllbcObservable.LazyOpType\n"
"        for lazy_op in self.__lazy_ops:\n"
"            if lazy_op.op_type == op_type.Add and lazy_op.observer.is_this(other):\n"
"                add_times += 1\n"
"            elif lazy_op.op_type == op_type.Remove and other.is_this(lazy_op.observer):\n"
"                add_times -= 1\n"
"            elif lazy_op.op_type == op_type.RemoveAll:\n"
"                add_times = 0\n"
"\n"
"        return add_times > 0\n"
"\n"
"    def add_observer(self, ob):\n"
"        \"\"\"\n"
"        Add observer.\n"
"        \"\"\"\n"
"        WrappedOb = pyllbcObservable.WrappedObserver\n"
"        if isinstance(ob, WrappedOb):\n"
"            wrapped_ob = ob\n"
"        else:\n"
"            wrapped_ob = WrappedOb(ob)\n"
"        if wrapped_ob in self:\n"
"            return\n"
"\n"
"        if not self.__notifying:\n"
"            self.__observers.append(wrapped_ob)\n"
"        else:\n"
"            lazy_op = pyllbcObservable.LazyOp\n"
"            op_type = pyllbcObservable.LazyOpType\n"
"\n"
"            lazy_op = lazy_op() \n"
"            lazy_op.op_type = op_type.Add\n"
"            lazy_op.observer = wrapped_ob\n"
"\n"
"            self.__lazy_ops.append(lazy_op)\n"
"\n"
"    def remove_observer(self, ob):\n"
"        \"\"\"\n"
"        Remove observer.\n"
"        \"\"\"\n"
"        if not self.__notifying:\n"
"            wrapped_ob = pyllbcObservable.WrappedObserver(ob)\n"
"\n"
"            observers = self.__observers\n"
"            for i in range(len(observers) -1, -1, -1):\n"
"                saved_wrapped_ob = observers[i]\n"
"                if not saved_wrapped_ob or \\\n"
"                        saved_wrapped_ob.is_this(wrapped_ob):\n"
"                    del self.__observers[i]\n"
"        else:\n"
"            lazy_op = pyllbcObservable.LazyOp\n"
"            op_type = pyllbcObservable.LazyOpType\n"
"\n"
"            lazy_op = lazy_op()\n"
"            lazy_op.observer = ob\n"
"            lazy_op.op_type = op_type.Remove\n"
"            self.__lazy_ops.append(lazy_op)\n"
"\n"
"    def remove_all_observers(self):\n"
"        \"\"\"\n"
"        Remove all observers.\n"
"        \"\"\"\n"
"        if not self.__notifying:\n"
"            del self.__observers[:]\n"
"        else:\n"
"            lazy_op = pyllbcObservable.LazyOp\n"
"            op_type = pyllbcObservable.LazyOpType\n"
"\n"
"            lazy_op = lazy_op()\n"
"            lazy_op.op_type = op_type.RemoveAll\n"
"            self.__lazy_ops.append(lazy_op)\n"
"\n"
"    def notify(self, data=None):\n"
"        \"\"\"\n"
"        Notify all observers\n"
"        \"\"\"\n"
"        if not self.__notifying:\n"
"            self.__notifying += 1\n"
"            \n"
"            will_del_indices = []\n"
"            observers = self.__observers\n"
"            for idx, observer in enumerate(observers):\n"
"                if not observer(self, data):\n"
"                    will_del_indices.append(idx)\n"
"\n"
"            for idx in xrange(len(will_del_indices) - 1, -1, -1):\n"
"                del observers[will_del_indices[idx]]\n"
"\n"
"            self.__notifying -= 1\n"
"            self.__process_hangup_ops()\n"
"        else:\n"
"            lazy_op_type = pyllbcObservable.LazyOpType\n"
"\n"
"            lazy_op = pyllbcObservable.LazyOp()\n"
"            lazy_op.op_type = lazy_op_type.Notify\n"
"            lazy_op.ntf_data = data\n"
"            self.__lazy_ops.append(lazy_op)\n"
"\n"
"    def __process_hangup_ops(self):\n"
"        \"\"\"\n"
"        Internal method, using to process hangup operations.\n"
"        \"\"\"\n"
"        if not self.__lazy_ops:\n"
"            return None\n"
"\n"
"        op_type = pyllbcObservable.LazyOpType\n"
"\n"
"        lazy_ops = self.__lazy_ops\n"
"        self.__lazy_ops = []\n"
"\n"
"        for lazy_op in lazy_ops:\n"
"            if lazy_op.op_type == op_type.Add:\n"
"                self.add_observer(lazy_op.observer)\n"
"            elif lazy_op.op_type == op_type.Remove:\n"
"                self.remove_observer(lazy_op.observer)\n"
"            elif lazy_op.op_type == op_type.RemoveAll:\n"
"                self.remove_all_observers()\n"
"            elif lazy_op.op_type == op_type.Notify:\n"
"                self.notify(lazy_op.ntf_data)\n"
"\n"
"llbc.Observable = pyllbcObservable\n"
"\n"
)));
        _scripts.insert(::std::make_pair("Func.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"def pyllbc_foreach(func, iterable):\n"
"    \"\"\"\n"
"    Traverse the iterable value to execute function, mo matter the func return.\n"
"    \"\"\"\n"
"    for elem in iterable:\n"
"        func(elem)\n"
"\n"
"llbc.foreach = pyllbc_foreach\n"
"\n"
)));
        _scripts.insert(::std::make_pair("GUID.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcGUID(object):\n"
"    \"\"\"The GUID about operations encapsulation\"\"\"\n"
"    def __init__(self):\n"
"        pass\n"
"\n"
"    @classmethod\n"
"    def generate(clazz):\n"
"        return llbc.inl.GenGUID()\n"
"\n"
"llbc.GUID = pyllbcGUID\n"
"\n"
)));
        _scripts.insert(::std::make_pair("Log.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import inspect as pyllbcInspect\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcLog(object):\n"
"    DEBUG = 0\n"
"    INFO = 1\n"
"    WARN = 2\n"
"    ERROR = 3\n"
"    FATAL = 4\n"
"\n"
"    __log_fileinfo = False\n"
"\n"
"    @staticmethod\n"
"    def init(cfg_file):\n"
"        \"\"\"Initialize log\"\"\"\n"
"        llbc.inl.InitLoggerMgr(cfg_file)\n"
"\n"
"    @classmethod\n"
"    def enablelogfileinfo(cls):\n"
"        \"\"\"Enable log file name and lineno informations to log file\"\"\"\n"
"        cls.__log_fileinfo = True\n"
"\n"
"    @classmethod\n"
"    def disablelogfileinfo(cls):\n"
"        \"\"\"Disabl log file name and lineno informations to log file\"\"\"\n"
"        cls.__log_fileinfo = False\n"
"\n"
"    @classmethod\n"
"    def d(cls, msg, logger='root', tag=''):\n"
"        \"\"\"Log debug level message\"\"\"\n"
"        cls.__logmsg(cls.DEBUG, msg, logger, tag)\n"
"\n"
"    @classmethod\n"
"    def i(cls, msg, logger='root', tag=''):\n"
"        \"\"\"Log info level message\"\"\"\n"
"        cls.__logmsg(cls.INFO, msg, logger, tag)\n"
"\n"
"    @classmethod\n"
"    def w(cls, msg, logger='root', tag=''):\n"
"        \"\"\"Log warn level message\"\"\"\n"
"        cls.__logmsg(cls.WARN, msg, logger, tag)\n"
"\n"
"    @classmethod\n"
"    def e(cls, msg, logger='root', tag=''):\n"
"        \"\"\"Log error level message\"\"\"\n"
"        cls.__logmsg(cls.ERROR, msg, logger, tag)\n"
"\n"
"    @classmethod\n"
"    def f(cls, msg, logger='root', tag=''):\n"
"        \"\"\"Log fatal level message\"\"\"\n"
"        cls.__logmsg(cls.FATAL, msg, logger, tag)\n"
"\n"
"    @classmethod\n"
"    def __logmsg(cls, lv, msg, logger='root', tag=''):\n"
"        \"\"\"Log specific level message\"\"\"\n"
"        if cls.__log_fileinfo:\n"
"            caller_stack = pyllbcInspect.stack()[2]\n"
"            filename = caller_stack[1]\n"
"            lineno = caller_stack[2]\n"
"        else:\n"
"            filename = None\n"
"            lineno = 0\n"
"\n"
"        if not isinstance(msg, str):\n"
"            if isinstance(msg, unicode):\n"
"                msg = msg.encode('utf-8')\n"
"            else:\n"
"                msg = str(msg)\n"
"\n"
"        llbc.inl.LogMsg(lv, filename, lineno, msg, logger, tag)\n"
"\n"
"\n"
"llbc.Log = pyllbcLog\n"
"\n"
)));
        _scripts.insert(::std::make_pair("Singleton.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcSingleton(object):\n"
"    _objs = {}\n"
"    \n"
"    def __new__(cls, *args, **kwargs):\n"
"        cls_dict = cls._objs.get(cls)\n"
"        if cls_dict is not None:\n"
"            return cls_dict['obj']\n"
"\n"
"        obj = object.__new__(cls)\n"
"        cls._objs[cls] = {'obj': obj, 'init': False}\n"
"        setattr(cls, '__init__', cls.decorate_init(cls.__init__))\n"
"        return obj\n"
"\n"
"    @classmethod\n"
"    def decorate_init(cls, func):\n"
"        def init_wrap(*args, **kwargs):\n"
"            if not cls._objs[cls]['init']:\n"
"                func(*args, **kwargs)\n"
"                cls._objs[cls]['init'] = True\n"
"            return\n"
"        return init_wrap\n"
"\n"
"llbc.Singleton = pyllbcSingleton\n"
"\n"
"\n"
)));
        _scripts.insert(::std::make_pair("BitSet.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcBitSet(object):\n"
"    \"\"\"\n"
"    pyllbc bitset class encapsulation.\n"
"    \"\"\"\n"
"    def __init__(self, init_bits=0):\n"
"        self._bits = long(init_bits)\n"
"\n"
"    @property\n"
"    def bits(self):\n"
"        return self._bits\n"
"\n"
"    def set_bits(self, bits):\n"
"        self._bits |= bits\n"
"\n"
"    def unset_bits(self, bits):\n"
"        self._bits &= (~bits)\n"
"\n"
"    def swap_bits(self, from_bits, to_bits):\n"
"        self.unset_bits(from_bits)\n"
"        self.set_bits(to_bits)\n"
"\n"
"    def has_bits(self, bits):\n"
"        return True if self._bits & bits == bits else False\n"
"\n"
"    def only_has_bits(self, bits):\n"
"        if self._bits & bits != bits:\n"
"            return False\n"
"        elif self._bits & (~bits) != 0:\n"
"            return False\n"
"        return True\n"
"\n"
"    def set_all(self):\n"
"        self._bits = -1\n"
"\n"
"    def unset_all(self, reset_bits=0):\n"
"        self._bits = reset_bits\n"
"\n"
"    def __str__(self):\n"
"        return self._i2b(self._bits)\n"
"\n"
"    @staticmethod\n"
"    def _i2b(bits):\n"
"        l = []\n"
"        n, m = divmod(bits, 2)\n"
"        l.append(str(m))\n"
"        while n != 0:\n"
"            n, m = divmod(n, 2)\n"
"            l.insert(0, str(m))\n"
"\n"
"        return ''.join(l)\n"
"\n"
"llbc.BitSet = pyllbcBitSet\n"
"\n"
)));
        _scripts.insert(::std::make_pair("ClsUtil.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"def pyllbc_ischild(child_cls, base_cls):\n"
"    if child_cls is base_cls:\n"
"        return True\n"
"    \n"
"    for cls in child_cls.__bases__:\n"
"        if pyllbc_ischild(cls, base_cls):\n"
"            return True\n"
"    return False\n"
"\n"
"llbc.ischild = pyllbc_ischild\n"
"\n"
)));
        _scripts.insert(::std::make_pair("InvokeGuard.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcInvokeGuard(object):\n"
"    \"\"\"\n"
"    pyllbc library Invoke-Guard class encapsulation\n"
"    \"\"\"\n"
"    def __init__(self, cbl=None, *args, **kwargs):\n"
"        self._cbl = cbl\n"
"        self._args, self._kwargs = args, kwargs\n"
"    \n"
"    def cancel(self):\n"
"        \"\"\"\n"
"        Cancel this guard\n"
"        \"\"\"\n"
"        self._cbl = None\n"
"        self._args, self._kwargs = None, None\n"
"\n"
"    def __del__(self):\n"
"        self._cbl(*self._args, **self._kwargs)\n"
"\n"
"llbc.InvokeGuard = pyllbcInvokeGuard\n"
"\n"
)));
        _scripts.insert(::std::make_pair("StrUtil.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcStrUtil(object):\n"
"    \"\"\"\n"
"    pyllbc string util class encapcsulation.\n"
"    \"\"\"\n"
"\n"
"    __native_hash_meth = llbc.inl.HashString\n"
"    @classmethod\n"
"    def hash_string(cls, s):\n"
"        \"\"\"\n"
"        hash string value\n"
"        \"\"\"\n"
"        return cls.__native_hash_meth(s)\n"
"\n"
"llbc.StrUtil = pyllbcStrUtil\n"
)));
        _scripts.insert(::std::make_pair("TestCase.py", new ::pyllbc_ScriptIntegrator("# -*- coding: utf-8 -*-\n"
"\n"
"import llbc\n"
"\n"
"class pyllbcTestCase(object):\n"
"    def __init__(self, name=\"\"):\n"
"        self.__c_obj = llbc.inl.NewTestCase(name)\n"
"\n"
"    def __del__(self):\n"
"        llbc.inl.DelTestCase(self.__c_obj)\n"
"\n"
"    def __call__(self, arg=None):\n"
"        return self.run(arg)\n"
"\n"
"    @property\n"
"    def name(self):\n"
"        return llbc.inl.GetTestCaseName(self.__c_obj)\n"
"        \n"
"    @name.setter\n"
"    def name(self, tcname):\n"
"        return llbc.inl.SetTestCaseName(self.__c_obj, tcname)\n"
"\n"
"    def run(self, arg=None):\n"
"        \"\"\"Please rewrite this method\"\"\"\n"
"        pass\n"
"\n"
"llbc.TestCase = pyllbcTestCase\n"
"\n"
)));
    }

public:
    ~pyllbc_Scripts()
    {
        LLBC_STLHelper::DeleteContainer(_scripts);
    }

public:
     int Integrate()
    {
        for (::std::map<LLBC_String, ::pyllbc_ScriptIntegrator *>::iterator it = _scripts.begin();
             it != _scripts.end();
             it++)
            if (it->second->Integrate() != LLBC_OK)
                return LLBC_FAILED;
        
        return LLBC_OK;
    }

private:
    ::std::map<LLBC_String, ::pyllbc_ScriptIntegrator *> _scripts;
};

#define pyllbc_s_Scripts LLBC_Singleton<pyllbc_Scripts, LLBC_DummyLock>::Instance()

#endif // !__PYLLBC_AUTOGEN_SRC_PYLLBC_SCRIPTS_H__

